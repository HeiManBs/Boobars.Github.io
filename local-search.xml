<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Vue3 特性</title>
    <link href="/2023/09/08/2023-09-08-Vue3%E7%89%B9%E6%80%A7/"/>
    <url>/2023/09/08/2023-09-08-Vue3%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="1-什么是Vue3？-Vue3有哪些新增特性？"><a href="#1-什么是Vue3？-Vue3有哪些新增特性？" class="headerlink" title="1. 什么是Vue3？ Vue3有哪些新增特性？"></a>1. 什么是Vue3？ Vue3有哪些新增特性？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Vue3是Vue.js框架的最新版本，它增加了很多新特性，包括Composition API、Teleport、Suspense 和Fragment等。<br></code></pre></td></tr></table></figure><h3 id="2-Vue3-Composition-API是什么？它的作用是什么？"><a href="#2-Vue3-Composition-API是什么？它的作用是什么？" class="headerlink" title="2. Vue3 Composition API是什么？它的作用是什么？"></a>2. Vue3 Composition API是什么？它的作用是什么？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Vue3 Composition API是Vue3中的一个新特性，它的作用是将组件中的逻辑分解成可复用的可组合函数。通过使用Composition API，可以更好地组织代码和管理状态。<br></code></pre></td></tr></table></figure><h3 id="3-Vue3中的Teleport是什么？它的作用是什么？"><a href="#3-Vue3中的Teleport是什么？它的作用是什么？" class="headerlink" title="3. Vue3中的Teleport是什么？它的作用是什么？"></a>3. Vue3中的Teleport是什么？它的作用是什么？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Vue3中的Teleport 是控制渲染位置的新指令。它的作用是在DOM中移动一个组件的内容而不改变组件的父级。<br></code></pre></td></tr></table></figure><h3 id="4-Vue3中的Suspense是什么？它的作用是什么？"><a href="#4-Vue3中的Suspense是什么？它的作用是什么？" class="headerlink" title="4.Vue3中的Suspense是什么？它的作用是什么？"></a>4.Vue3中的Suspense是什么？它的作用是什么？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Vue3中的Suspense是Vue3中新增的一个组件，它的作用是实现延迟加载和错误处理。在组件中加入Suspense，可以让异步组件可以渲染出加载状态，并且如果异步组件加载时出现错误，也能够处理这些错误。<br></code></pre></td></tr></table></figure><h3 id="5-Vue3中的Fragment是什么？它的作用是什么？"><a href="#5-Vue3中的Fragment是什么？它的作用是什么？" class="headerlink" title="5.Vue3中的Fragment是什么？它的作用是什么？"></a>5.Vue3中的Fragment是什么？它的作用是什么？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Vue3中的Fragment是用来承载多个子元素的虚拟组件。它的作用是可以解决在Vue2中，使用v-for迭代元素时需要添加一个包装元素的问题。<br></code></pre></td></tr></table></figure><h3 id="6-什么是响应式系统？-Vue3中的响应式系统有哪些更新？"><a href="#6-什么是响应式系统？-Vue3中的响应式系统有哪些更新？" class="headerlink" title="6. 什么是响应式系统？ Vue3中的响应式系统有哪些更新？"></a>6. 什么是响应式系统？ Vue3中的响应式系统有哪些更新？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">响应式系统是Vue中的核心概念之一，它允许在状态发生变化时更新视图。Vue3中的响应式系统更新包括Proxy、Reflect和WeakMap等。<br></code></pre></td></tr></table></figure><h3 id="7-Vue3中的事件修饰符有哪些？"><a href="#7-Vue3中的事件修饰符有哪些？" class="headerlink" title="7. Vue3中的事件修饰符有哪些？"></a>7. Vue3中的事件修饰符有哪些？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Vue3中的事件修饰符与Vue2基本相同，包括stop、prevent、capture和self等。<br></code></pre></td></tr></table></figure><h3 id="8-Vue3中的指令有哪些？"><a href="#8-Vue3中的指令有哪些？" class="headerlink" title="8. Vue3中的指令有哪些？"></a>8. Vue3中的指令有哪些？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Vue3中的指令包括v-if、v-for、v-bind、v-on、v-html、v-model、v-show、v-slot、v-text等。<br></code></pre></td></tr></table></figure><h3 id="9-Vue3中如何实现动态组件？"><a href="#9-Vue3中如何实现动态组件？" class="headerlink" title="9. Vue3中如何实现动态组件？"></a>9. Vue3中如何实现动态组件？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Vue3中使用 &lt;component&gt; 元素和 v-bind:is 属性来实现动态组件。例如， &lt;component v-bind:is=<span class="hljs-string">&quot;currentComponent&quot;</span>&gt;&lt;/component&gt; 。<br></code></pre></td></tr></table></figure><h3 id="10-Vue3如何实现异步组件加载？"><a href="#10-Vue3如何实现异步组件加载？" class="headerlink" title="10.  Vue3如何实现异步组件加载？"></a>10.  Vue3如何实现异步组件加载？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Vue3中使用 import() 来异步加载组件。<br><br></code></pre></td></tr></table></figure><h3 id="11-Vue3如何实现插槽？"><a href="#11-Vue3如何实现插槽？" class="headerlink" title="11.  Vue3如何实现插槽？"></a>11.  Vue3如何实现插槽？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Vue3中使用 &lt;slot name=<span class="hljs-string">&quot;slot-name&quot;</span>&gt;&lt;/slot&gt; 来实现插槽。在父组件中使用 &lt;template v-slot:slot-name&gt;&lt;/template&gt; 来填充插槽。<br></code></pre></td></tr></table></figure><h3 id="12-Vue3如何实现自定义指令？"><a href="#12-Vue3如何实现自定义指令？" class="headerlink" title="12.  Vue3如何实现自定义指令？"></a>12.  Vue3如何实现自定义指令？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Vue3使用 app.directive() 方法来注册指令，例如 app.directive(<span class="hljs-string">&#x27;focus&#x27;</span>, &#123;mounted(el) &#123;el.focus()&#125;&#125;) 。<br></code></pre></td></tr></table></figure><h3 id="13-Vue3如何实现混入？"><a href="#13-Vue3如何实现混入？" class="headerlink" title="13.  Vue3如何实现混入？"></a>13.  Vue3如何实现混入？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Vue3使用 app.mixin() 方法来注册混入，例如 app.mixin(&#123;<span class="hljs-function"><span class="hljs-title">created</span></span>() &#123;console.log(<span class="hljs-string">&#x27;mixin created&#x27;</span>)&#125;&#125;) 。<br></code></pre></td></tr></table></figure><h3 id="14-Vue3如何实现自定义渲染函数？"><a href="#14-Vue3如何实现自定义渲染函数？" class="headerlink" title="14.  Vue3如何实现自定义渲染函数？"></a>14.  Vue3如何实现自定义渲染函数？</h3> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Vue3使用 h() 函数来创建虚拟节点，例如 h(<span class="hljs-string">&#x27;div&#x27;</span>, &#123;class: <span class="hljs-string">&#x27;container&#x27;</span>&#125;, <span class="hljs-string">&#x27;Hello, world&#x27;</span>) 。<br><br></code></pre></td></tr></table></figure><h3 id="15-Vue3中的响应式系统如何处理循环引用问题？"><a href="#15-Vue3中的响应式系统如何处理循环引用问题？" class="headerlink" title="15.  Vue3中的响应式系统如何处理循环引用问题？"></a>15.  Vue3中的响应式系统如何处理循环引用问题？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Vue3中使用WeakMap来处理循环引用问题。<br></code></pre></td></tr></table></figure><h3 id="16-Vue3如何实现全局状态管理？"><a href="#16-Vue3如何实现全局状态管理？" class="headerlink" title="16.  Vue3如何实现全局状态管理？"></a>16.  Vue3如何实现全局状态管理？</h3> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Vue3中使用 provide() 和 inject() 函数来实现全局状态管理。<br></code></pre></td></tr></table></figure><h3 id="17-Vue3中的ref指令有哪些用途？"><a href="#17-Vue3中的ref指令有哪些用途？" class="headerlink" title="17.  Vue3中的ref指令有哪些用途？"></a>17.  Vue3中的ref指令有哪些用途？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Vue3中的ref指令可以用来在组件内部获取子组件的实例，也可以用来获取DOM元素或其他组件的实例。<br><br></code></pre></td></tr></table></figure><h3 id="18-Vue3中的setup-函数有什么用途？"><a href="#18-Vue3中的setup-函数有什么用途？" class="headerlink" title="18.  Vue3中的setup()函数有什么用途？"></a>18.  Vue3中的setup()函数有什么用途？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Vue3中的setup()函数是用来替代Vue2中的data、methods和computed等选项的。它可以用来创建响应式数据和添加需要在模板中使用的方法。<br></code></pre></td></tr></table></figure><h3 id="19-Vue3如何使用provide和inject实现依赖注入？"><a href="#19-Vue3如何使用provide和inject实现依赖注入？" class="headerlink" title="19.  Vue3如何使用provide和inject实现依赖注入？"></a>19.  Vue3如何使用provide和inject实现依赖注入？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">在父组件中使用 provide() ，并在子组件中使用 inject() 来注入依赖项。<br></code></pre></td></tr></table></figure><h3 id="20-Vue3如何实现异步验证表单输入？"><a href="#20-Vue3如何实现异步验证表单输入？" class="headerlink" title="20.  Vue3如何实现异步验证表单输入？"></a>20.  Vue3如何实现异步验证表单输入？</h3> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">使用 watch() 函数，监听表单输入的变化，并使用异步函数处理验证逻辑。<br></code></pre></td></tr></table></figure><h3 id="21-Vue3中如何使用路由？"><a href="#21-Vue3中如何使用路由？" class="headerlink" title="21.  Vue3中如何使用路由？"></a>21.  Vue3中如何使用路由？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Vue3中使用Vue Router来实现路由。首先需要安装Vue Router，然后使用 createRouter() 函数创建路由对象，然后在根Vue实例中使用 app.use() 方法注册Vue Router。<br></code></pre></td></tr></table></figure><h3 id="22-Vue3中的provide注入的依赖项如何在子组件中更新？"><a href="#22-Vue3中的provide注入的依赖项如何在子组件中更新？" class="headerlink" title="22.  Vue3中的provide注入的依赖项如何在子组件中更新？"></a>22.  Vue3中的provide注入的依赖项如何在子组件中更新？</h3> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">通过给provide注入的对象添加响应式属性来让子组件能够更新依赖项。<br><br></code></pre></td></tr></table></figure><h3 id="23-Vue3中如何使用axios发送HTTP请求？"><a href="#23-Vue3中如何使用axios发送HTTP请求？" class="headerlink" title="23.  Vue3中如何使用axios发送HTTP请求？"></a>23.  Vue3中如何使用axios发送HTTP请求？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">在Vue3中使用axios发送HTTP请求，需要先安装axios，并在组件中导入axios。然后可以使用axios的get、post、put、delete等方法来发送HTTP请求。<br></code></pre></td></tr></table></figure><h3 id="24-Vue3如何使用vuex进行状态管理？"><a href="#24-Vue3如何使用vuex进行状态管理？" class="headerlink" title="24.  Vue3如何使用vuex进行状态管理？"></a>24.  Vue3如何使用vuex进行状态管理？</h3> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Vue3中使用Vuex进行状态管理，需要先安装Vuex，并在根Vue实例中使用 app.use() 方法注册Vuex。然后在组件中使用 store 选项来创建和访问Vuex的状态。<br></code></pre></td></tr></table></figure><h3 id="25-Vue3中如何使用emit事件来与父组件通信？"><a href="#25-Vue3中如何使用emit事件来与父组件通信？" class="headerlink" title="25.  Vue3中如何使用emit事件来与父组件通信？"></a>25.  Vue3中如何使用emit事件来与父组件通信？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">在子组件中使用 this.<span class="hljs-variable">$emit</span>() 方法触发 emit 事件，并将需要传递的数据作为参数传递给父组件。<br></code></pre></td></tr></table></figure><h3 id="26-Vue3中如何使用slot来构建可复用组件？"><a href="#26-Vue3中如何使用slot来构建可复用组件？" class="headerlink" title="26.  Vue3中如何使用slot来构建可复用组件？"></a>26.  Vue3中如何使用slot来构建可复用组件？</h3> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">在组件中使用 &lt;slot&gt; 元素来定义插槽，在父组件中使用 &lt;template v-slot:slot-name&gt; 来填充插槽。<br></code></pre></td></tr></table></figure><h3 id="27-Vue3中如何处理条件渲染？"><a href="#27-Vue3中如何处理条件渲染？" class="headerlink" title="27.  Vue3中如何处理条件渲染？"></a>27.  Vue3中如何处理条件渲染？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">使用 v-if 指令来实现条件渲染。<br></code></pre></td></tr></table></figure><h3 id="28-Vue3中如何处理列表渲染？"><a href="#28-Vue3中如何处理列表渲染？" class="headerlink" title="28.  Vue3中如何处理列表渲染？"></a>28.  Vue3中如何处理列表渲染？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">使用 v-for 指令来实现列表渲染。<br></code></pre></td></tr></table></figure><h3 id="29-Vue3中如何处理动态绑定属性？"><a href="#29-Vue3中如何处理动态绑定属性？" class="headerlink" title="29.  Vue3中如何处理动态绑定属性？"></a>29.  Vue3中如何处理动态绑定属性？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">使用 v-bind 指令来实现动态绑定属性。<br></code></pre></td></tr></table></figure><h3 id="30-Vue3中如何处理事件绑定？"><a href="#30-Vue3中如何处理事件绑定？" class="headerlink" title="30.  Vue3中如何处理事件绑定？"></a>30.  Vue3中如何处理事件绑定？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">使用 v-on 指令来实现事件绑定。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端</title>
    <link href="/2023/06/16/2023-06-16-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%981/"/>
    <url>/2023/06/16/2023-06-16-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%981/</url>
    
    <content type="html"><![CDATA[<h3 id="1-css3有哪些新特性？"><a href="#1-css3有哪些新特性？" class="headerlink" title="1.css3有哪些新特性？"></a>1.css3有哪些新特性？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">1、css3选择器；2、边框特性；3、多背景图；4、颜色与透明度；5、多列布局与弹性盒模型布局；6、盒子的变形；7、过渡与动画；8、web字体；9、媒体查询；10、阴影。<br></code></pre></td></tr></table></figure><h3 id="2-伪元素和伪类分别有几个冒号？"><a href="#2-伪元素和伪类分别有几个冒号？" class="headerlink" title="2.伪元素和伪类分别有几个冒号？"></a>2.伪元素和伪类分别有几个冒号？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">一、伪类（一个冒号）<br>1、伪类：伪类表示一个元素身上的一种状态，给伪类设置样式，样式作用于元素身上，因为它不是一个实实在在的东西；<br>2、伪类有哪些：<br><br>如：<br><span class="hljs-built_in">link</span>,<br>visited,<br>active,<br>div:hover,<br>div:nth-child()   //css3选择器等<br><br>二、伪元素（两个冒号）<br>1、伪元素：伪元素可以理解为它是一个实实在在的东西，指的就是元素，只不过是个虚假元素，且它这个元素没有标签。但是它依然可以设置宽高等样式。<br>2、伪元素都有哪些：<br><br>::first-letter  //获取到第一个文本<br>::first-line    //获取到第一行<br>::selection     //设置文本选中的样式<br>::before  <br>::after         <br><br>  双冒号IE8不兼容，但是为了规范建议写两个冒号。<br><br></code></pre></td></tr></table></figure><h3 id="3-说一下css选择器的优先级"><a href="#3-说一下css选择器的优先级" class="headerlink" title="3.说一下css选择器的优先级"></a>3.说一下css选择器的优先级</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">!important、行内样式、ID选择器、类选择器、属性选择器、伪类选择器、元素选择器、伪元素选择器<br><br></code></pre></td></tr></table></figure><h3 id="4-如何让盒子水平垂直居中？"><a href="#4-如何让盒子水平垂直居中？" class="headerlink" title="4.如何让盒子水平垂直居中？"></a>4.如何让盒子水平垂直居中？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">利用父绝子相定位、固定定位、利用margin:auto、利用display:table-cel、利用display:flex<br></code></pre></td></tr></table></figure><h3 id="5-router和-route-区别？"><a href="#5-router和-route-区别？" class="headerlink" title="5.$router和 $route 区别？"></a>5.$router和 $route 区别？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">route：是一个当前路由信息的对象，包括当前 URL 路径、查询参数、路径参数等信息。对象是只读的，不可以直接修改其属性值，而需要通过路由跳转来更新。<br>router：是 Vue Router 的实例对象，包括了许多用于导航控制和路由操作的 API，例如 push、replace、go、forward 等方法。router 可以用来动态地改变 URL，从而实现页面间的无刷新跳转。<br>因此，route 和 router 在功能上有所不同，route 主要用于获取当前路由信息，router 则是用于进行路由操作，例如跳转到指定的路由、前进、后退等。<br></code></pre></td></tr></table></figure><h3 id="6-标准盒模型和IE盒模型有什么区别？？"><a href="#6-标准盒模型和IE盒模型有什么区别？？" class="headerlink" title="6.标准盒模型和IE盒模型有什么区别？？"></a>6.标准盒模型和IE盒模型有什么区别？？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">标准盒模型中：元素的width和height属性分别是指content的宽度和高度，不含padding和border。<br>IE盒模型中：元素的width和height属性包含了content、padding和border。这两种盒模型的区别在于计算宽度和高度的方式不同。<br></code></pre></td></tr></table></figure><h3 id="7-如何将String转Number"><a href="#7-如何将String转Number" class="headerlink" title="7.如何将String转Number"></a>7.如何将String转Number</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">Var str=‘123’<br>parseInt(str)、<br>Number(str)、<br>一元运算符 (+str)、<br>parseFloat(str)、 <br>Math.floor(str)、<br>乘以str*1、 <br>(~~str) 运算符<br></code></pre></td></tr></table></figure><h3 id="8-javaScript的数组和对象怎么相互转换？"><a href="#8-javaScript的数组和对象怎么相互转换？" class="headerlink" title="8. javaScript的数组和对象怎么相互转换？"></a>8. javaScript的数组和对象怎么相互转换？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs bash">数组转对象：<br>// 利用Object.assign()方法<br>const arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br>const obj1 = Object.assign(&#123;&#125;, arr);<br><br>console.log(obj1); // 输出&#123;0: <span class="hljs-string">&quot;a&quot;</span>, 1: <span class="hljs-string">&quot;b&quot;</span>, 2: <span class="hljs-string">&quot;c&quot;</span>&#125;<br><br>// 利用reduce()方法<br>const obj2 = arr.reduce((acc, val, index) =&gt; &#123;<br>  acc[index] = val;<br>  return acc;<br>&#125;, &#123;&#125;);<br><br>console.log(obj2); // 输出&#123;<span class="hljs-number">0</span>: &quot;a&quot;, <span class="hljs-number">1</span>: &quot;b&quot;, <span class="hljs-number">2</span>: &quot;c&quot;&#125;<br><br>// 利用for循环遍历数组的方法<br>const obj3 = &#123;&#125;;<br><br>for (let i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>  obj3[i] = arr[i];<br>&#125;<br><br>console.log(obj3); // 输出&#123;<span class="hljs-number">0</span>: &quot;a&quot;, <span class="hljs-number">1</span>: &quot;b&quot;, <span class="hljs-number">2</span>: &quot;c&quot;&#125;<br><br>对象转数组：<br>// 将对象转换为数组，利用Object.keys<br>const obj = &#123;a: <span class="hljs-number">1</span>, b: <span class="hljs-number">2</span>, c: <span class="hljs-number">3</span>&#125;;<br><br>const arr1 = Object.keys(obj).map((key) =&gt; &#123;<br>  return obj[key];<br>&#125;);<br><br>console.log(arr1); // 输出[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br>// 将对象转换为数组，利用JSON.stringify和JSON.parse<br>const arr2 = JSON.parse(JSON.stringify(obj));<br><br>console.log(arr2); // 输出&#123;a: 1, b: 2, c: 3&#125;<br></code></pre></td></tr></table></figure><h3 id="9-javascript中什么叫-序列化？"><a href="#9-javascript中什么叫-序列化？" class="headerlink" title="9.javascript中什么叫 序列化？"></a>9.javascript中什么叫 序列化？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">在javascript中，就是指将一个在内存中的变量转换为可保存或传输的字符串的过程，可以使用“JSON.stringify()”方法来实现序列化，它可将 JavaScript 值转换为 JSON 字符串。反序列化就需要使用“JSON.parse()”方法。<br></code></pre></td></tr></table></figure><h3 id="10-Websocket配置以及使用"><a href="#10-Websocket配置以及使用" class="headerlink" title="10.Websocket配置以及使用"></a>10.Websocket配置以及使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash">// WebSocket构造函数，创建WebSocket对象<br><span class="hljs-built_in">let</span> ws = new WebSocket(<span class="hljs-string">&#x27;ws://localhost:8888&#x27;</span>)<br><br>// 连接成功后的回调函数<br>ws.onopen = <span class="hljs-keyword">function</span> (params) &#123;<br>  console.log(<span class="hljs-string">&#x27;客户端连接成功&#x27;</span>)<br>  // 向服务器发送消息<br>  ws.send(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>&#125;;<br><br>// 从服务器接受到信息时的回调函数<br>ws.onmessage = <span class="hljs-keyword">function</span> (e) &#123;<br>  console.log(<span class="hljs-string">&#x27;收到服务器响应&#x27;</span>, e.data)<br>&#125;;<br><br>// 连接关闭后的回调函数<br>ws.onclose = <span class="hljs-keyword">function</span>(evt) &#123;<br>  console.log(<span class="hljs-string">&quot;关闭客户端连接&quot;</span>);<br>&#125;;<br><br>// 连接失败后的回调函数<br>ws.onerror = <span class="hljs-keyword">function</span> (evt) &#123;<br>  console.log(<span class="hljs-string">&quot;连接失败了&quot;</span>);<br>&#125;;<br><br><br>// 监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，这样服务端会抛异常。<br>window.onbeforeunload = <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>    ws.close();<br>&#125;  <br></code></pre></td></tr></table></figure><h3 id="11-在项目中什么是虚拟DOM？？"><a href="#11-在项目中什么是虚拟DOM？？" class="headerlink" title="11.在项目中什么是虚拟DOM？？"></a>11.在项目中什么是虚拟DOM？？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">实际上它只是一层对真实DOM的抽象，以JavaScript 对象 (VNode 节点) 作为基础的树，用对象的属性来描述节点，最终可以通过一系列操作使这棵树映射到真实环境上<br>在Javascript对象中，虚拟DOM 表现为一个 Object对象。并且最少包含标签名 (tag)、属性 (attrs) 和子元素对象 (children) 三个属性，不同框架对这三个属性的名命可能会有差别<br>创建虚拟DOM就是为了更好将虚拟的节点渲染到页面视图中，所以虚拟DOM对象的节点与真实DOM的属性一一照应<br></code></pre></td></tr></table></figure><h3 id="12-什么是前端工程化？"><a href="#12-什么是前端工程化？" class="headerlink" title="12.什么是前端工程化？"></a>12.什么是前端工程化？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">在前端开发过程中，将前端开发的流程、工具和规范化，并使用相关技术实现自动化。前端工程化的核心概念包括模块化、打包构建、自动化部署、自动化测试和持续集成等<br>·  前端模块化：CommonJS、AMD、ES6模块化等<br>·  打包构建：  Webpack、Rollup等<br>·  自动化部署：Jenkins、Travis CI等<br>·  自动化测试：Jest、Mocha、Karma等<br>·  持续集成：  Jenkins、Travis CI等<br>·  React项目的打包构建：使用Webpack将多个模块打包成一个文件，并进行优化和压缩，减少页面加载时间和提高性能。<br>·  Vue.js项目的自动化部署：使用Travis CI实现自动化测试和部署，自动构建并部署代码到服务器，减少手动操作，提高效率。<br>·  Angular项目的自动化测试：使用Jest和Karma进行自动化测试，覆盖率高，能够及时发现代码中的问题，提高代码质量。<br></code></pre></td></tr></table></figure><h3 id="13-怎么实现无感刷新token的操作？"><a href="#13-怎么实现无感刷新token的操作？" class="headerlink" title="13.怎么实现无感刷新token的操作？"></a>13.怎么实现无感刷新token的操作？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">要做到token的无感刷新，主要有3种方案：<br><br>方案一：<br>后端返回过期时间，前端每次请求就判断token的过期时间，如果快到过期时间，就去调用刷新token接口。<br><br>缺点：需要后端额外提供一个token过期时间的字段；使用了本地时间判断，若本地时间被篡改，特别是本地时间比服务器时间慢时，拦截会失败。<br><br>方法二<br>写个定时器，然后定时刷新token接口。<br>缺点：浪费资源，消耗性能,不建议采用。<br><br>方法三<br>在请求响应拦截器中拦截，判断token 返回过期后，调用刷新token接口。<br><br>综合上面的三个方法，最好的是第三个，因为它不需要占用额外的资源。<br></code></pre></td></tr></table></figure><h3 id="14-门户网站搭建选型以及构思？"><a href="#14-门户网站搭建选型以及构思？" class="headerlink" title="14.门户网站搭建选型以及构思？"></a>14.门户网站搭建选型以及构思？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.用户体验设计（1.界面设计简洁美观。2.网站信息架构描述齐全。3.响应式布局设计适配多端）<br>2.技术选型与开发（1.选择适合的技术框架。2.采用模块化开发便于维护或提高开发效率。3.网站质量和数据安全保障）<br>3.内容管理与运营（1.定期更新内容。2.引入社区功能。3.分析用户行为）<br></code></pre></td></tr></table></figure><h3 id="15-SEO搜索引擎如何优化？"><a href="#15-SEO搜索引擎如何优化？" class="headerlink" title="15.SEO搜索引擎如何优化？"></a>15.SEO搜索引擎如何优化？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 确定关键词<br><br>关键词是指用户在搜索引擎中输入的查询词汇。确定关键词是SEO优化的基础。如果您的网站能够覆盖到用户的关键词，那么您的网站就有机会获得更多的点击量。因此，您需要通过关键词分析工具来确定您的关键词，并将其用于网站的标题、描述、内容和标签中。<br><br>2. 优化标题和描述<br><br>标题和描述是搜索引擎识别网站内容的重要因素。因此，您需要优化网站的标题和描述，以达到更好的搜索引擎排名。在设置标题时，您需要将关键词放在前面，并保持标题简短、精确、吸引人。描述也需要包含关键词，并描述网站的内容和特点。<br><br>3. 优化网站内容<br><br>网站内容是SEO优化的重点。您需要确保您的网站内容丰富、独特、有价值，并包含关键词。此外，您还需要遵循良好的写作规范，如使用段落、标题、标点符号、内部链接等。这些规范不仅可以让搜索引擎更好地理解您的内容，还可以提高用户体验。<br><br>4. 内部链接优化<br><br>内部链接是指在网站内部链接到其他页面的链接。内部链接优化可以帮助搜索引擎更好地理解您的网站内容和结构，提高网站的排名。您需要确保内部链接的文本包含关键词，链接到相关的页面，并避免使用无意义的链接文本。此外，您还可以使用网站地图来帮助搜索引擎更好地了解您的网站结构和内容。<br><br>5. 外部链接优化<br><br>外部链接是指其他网站链接到您的网站。外部链接优化是提高网站排名的重要因素。您需要争取获得高质量的外部链接，如来自权威网站或相关主题的网站。此外，您还需要避免使用黑帽SEO技术，如购买链接或使用链接农场，这些做法可能会导致您的网站被搜索引擎惩罚。<br><br>6. 网站速度优化<br><br>网站速度是用户体验和SEO排名的重要因素。您需要确保您的网站加载速度快，尽量避免使用大量的图片、视频和JavaScript等元素。您还可以使用缓存技术和内容分发网络（CDN）等技术来优化网站速度。<br><br>7. 移动友好性优化<br><br>移动设备已经成为许多用户的主要设备。因此，您需要确保您的网站在移动设备上能够良好地显示和使用。您可以使用响应式设计或移动网站来优化移动友好性，并提高网站在移动搜索中的排名。<br></code></pre></td></tr></table></figure><h3 id="16-与-的区别？？"><a href="#16-与-的区别？？" class="headerlink" title="16.&#x3D;&#x3D;与&#x3D;&#x3D;&#x3D;的区别？？"></a>16.&#x3D;&#x3D;与&#x3D;&#x3D;&#x3D;的区别？？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">== 是变量的值一样，可以数据类型不一样 返回<span class="hljs-literal">true</span><br>=== 需要变量的值一样，数据类型也要一样 返回<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="17-哪些是块级元素和行内元素？"><a href="#17-哪些是块级元素和行内元素？" class="headerlink" title="17.哪些是块级元素和行内元素？"></a>17.哪些是块级元素和行内元素？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">行内元素：　　<br>与其他行内元素并排<br>不能设置宽高，默认的宽度就是文字的宽度<br>块级元素：<br>霸占一行，不能与其他任何元素并列。<br>能接受宽高，如果不设置宽度，那么宽度将默认变为父级的100%。<br>块级元素：div，p，from，ul，li，ol，dl，address，fieldset，hr，menu，table<br>行内元素：span，strong，em，br，img，input，label，<span class="hljs-keyword">select</span>，textarea，cite<br></code></pre></td></tr></table></figure><h3 id="18-防抖节流代码实现？"><a href="#18-防抖节流代码实现？" class="headerlink" title="18.防抖节流代码实现？"></a>18.防抖节流代码实现？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs bash">防抖：<br><br><span class="hljs-keyword">function</span> debounce(fn, delay) &#123;<br>  <span class="hljs-built_in">let</span> timer = null;<br>  <span class="hljs-built_in">return</span> <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>    clearTimeout(timer);<br>    timer = setTimeout(() =&gt; &#123;<br>      fn.apply(this, arguments);<br>    &#125;, delay);<br>  &#125;;<br>&#125;<br>调用方式：<br><br>const debouncedFunction = debounce(function() &#123;<br>  // 这里是要执行的函数<br>&#125;, <span class="hljs-number">1000</span>);<br>节流：<br><br>function throttle(fn, delay) &#123;<br>  let timer = null;<br>  return function() &#123;<br>    if (timer) &#123;<br>      return;<br>    &#125;<br>    timer = setTimeout(() =&gt; &#123;<br>      fn.apply(this, arguments);<br>      timer = null;<br>    &#125;, delay);<br>  &#125;;<br>&#125;<br>调用方式：<br><br>const throttledFunction = throttle(function() &#123;<br>  // 这里是要执行的函数<br>&#125;, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><h3 id="19-router-link-与router-view的区别？"><a href="#19-router-link-与router-view的区别？" class="headerlink" title="19.router-link 与router-view的区别？"></a>19.router-link 与router-view的区别？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;router-link to=<span class="hljs-string">&quot;&quot;</span>/&gt; 相当于路由入口，会被渲染成一个a标签，to会被渲染成href属性<br>&lt;router-view /&gt; 相当于一个出口，用来做预渲染的，他会根据路由来匹配组件，然后把组件渲染出来<br></code></pre></td></tr></table></figure><h3 id="20-什么是路由守卫及配置？？"><a href="#20-什么是路由守卫及配置？？" class="headerlink" title="20.什么是路由守卫及配置？？"></a>20.什么是路由守卫及配置？？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs bash">一、 全局路由守卫<br>//  先在router的index.js中，使用VueRouter<br> <br>Vue.use(VueRouter)<br> <br>//  在路由的路径中，可以设置meta，以便进行一些守卫的判断，比如：<br>const routes = [<br>  &#123;<br>    path: <span class="hljs-string">&#x27;/index&#x27;</span>,<br>    component: Index,<br>    meta: &#123;<br>        needLogin: <span class="hljs-literal">true</span><br>    &#125;<br>  &#125;<br>]<br> <br>//  然后实例化VueRouter<br> <br>const router = new VueRouter(&#123;<br>  // 是否设为哈希模式  <span class="hljs-built_in">hash</span>  <span class="hljs-built_in">history</span><br>  // mode: <span class="hljs-string">&#x27;history&#x27;</span>,<br>  // 配置基路径<br>  base: process.env.BASE_URL,  // process.env是node.js的一种环境对象<br>  // 守卫的范围<br>  routes<br>&#125;)<br> <br>//  接着   to 表示去哪的路由  from表示从哪来的路由  next表示一个回调函数<br>//  next()//直接进to 所指路由<br>//  next(<span class="hljs-literal">false</span>) //中断当前路由<br>//  next(<span class="hljs-string">&#x27;route&#x27;</span>) //跳转指定路由<br>//  next(<span class="hljs-string">&#x27;error&#x27;</span>) //跳转错误路由<br> <br>router.beforeEach((to, from,next) =&gt; &#123;<br>  //  判断是否需要守卫<br>  if (to.meta.needLogin)&#123;<br>    //  通过请求即时判断登陆状态<br>    myinfo().then(res=&gt;&#123;<br>      //  登陆了<br>      if (res.data.code==<span class="hljs-number">0</span>)&#123;<br>        //  直接放行<br>        next()<br>      &#125;else &#123;<br>        //  没登陆 弹框提示 并跳转到登录、注册页面<br>        Dialog.alert(&#123;<br>          message: &#x27;请先登录&#x27;,<br>        &#125;).then(() =&gt; &#123;<br>          // on close<br>        &#125;);<br>        next(&#x27;/login&#x27;)<br>      &#125;<br>    &#125;)<br>  &#125;else &#123;<br>    next()<br>  &#125;<br>&#125;)<br> 二、组件间路由<br>//  跟methods: &#123;&#125;  等同级别书写   <br> <br>//  在路由进入之前，组件实例还未渲染，所以无法获取this实例，只能通过vm来访问组件实例<br>beforeRouteEnter (to, from, next) &#123;<br>  next(<br>    vm =&gt; &#123;&#125;<br>  )<br>&#125;<br> <br>//  同一页面，刷新不同数据时调用<br>beforeRouteUpdate (to, from, next) &#123;<br>  next(<br>    vm =&gt; &#123;&#125;<br>  )<br>&#125; <br> <br>//  离开当前路由页面时调用<br>beforeRouteLeave (to, from, next) &#123;<br>  next(<br>    vm =&gt; &#123;&#125;<br>  )<br>&#125;<br> 三、router独享守卫<br>//  直接在routes中的路由里<br> <br>const routes = [<br>  &#123;<br>    path: &#x27;/index&#x27;,<br>    component: Index,<br>    beforeEnter: (to, from, next) =&gt; &#123;<br>        next()<br>    &#125;<br>  &#125;<br>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue</title>
    <link href="/2023/05/16/2023-05-16-Vue1/"/>
    <url>/2023/05/16/2023-05-16-Vue1/</url>
    
    <content type="html"><![CDATA[<h3 id="1-vue中css文件scoped的作用"><a href="#1-vue中css文件scoped的作用" class="headerlink" title="1.vue中css文件scoped的作用"></a>1.vue中css文件scoped的作用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">scoped原理：<br>1， vue中的 scoped 属性，其实就是给每一个dom节点元素都添加了不重复的自定义属性（如：data-v-6810cbe5）；<br>2，然后编译时再给样式的末尾添加属性选择器进行样式私有化（如.btn[data-v-6810cbe5]）；<br>如下：<br><br>转译前的代码：<br><br>btn组件（使用了Vant组件库的button组件）：<br><br>&lt;template&gt;<br>  &lt;div class=<span class="hljs-string">&quot;copy1&quot;</span>&gt;<br>    &lt;van-button <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;default&quot;</span>&gt;默认按钮&lt;/van-button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped lang=<span class="hljs-string">&quot;scss&quot;</span>&gt;<br>.van-button &#123;<br>    background-color: red;<br>  &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h3 id="2-Vue里data中给对象添加新属性界面不刷新"><a href="#2-Vue里data中给对象添加新属性界面不刷新" class="headerlink" title="2.Vue里data中给对象添加新属性界面不刷新?"></a>2.Vue里data中给对象添加新属性界面不刷新?</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs bash">Vue 不允许在已经创建的实例上动态添加新的响应式属性<br><br>若想实现数据与视图同步更新，可采取下面三种解决方案：<br><br>Vue.<span class="hljs-built_in">set</span>()<br><br>Object.assign()<br><br><span class="hljs-variable">$forcecUpdated</span>()<br><br>(1)Vue.<span class="hljs-built_in">set</span>()<br>Vue.<span class="hljs-built_in">set</span>( target, propertyName/index, value )<br><br>参数<br><br>&#123;Object | Array&#125; target<br><br>&#123;string | number&#125; propertyName/index<br><br>&#123;any&#125; value<br><br>返回值：设置的值<br><br>通过Vue.<span class="hljs-built_in">set</span>向响应式对象中添加一个property，并确保这个新 property同样是响应式的，且触发视图更新<br><br>关于Vue.<span class="hljs-built_in">set</span>源码（省略了很多与本节不相关的代码）<br><br>源码位置：src\core\observer\index.js<br><br><span class="hljs-keyword">function</span> <span class="hljs-built_in">set</span> (target: Array&lt;any&gt; | Object, key: any, val: any): any &#123;<br>  ...<br>  defineReactive(ob.value, key, val)<br>  ob.dep.notify()<br>  <span class="hljs-built_in">return</span> val<br>&#125;<br>这里无非再次调用defineReactive方法，实现新增属性的响应式<br><br>关于defineReactive方法，内部还是通过Object.defineProperty实现属性拦截<br><br>大致代码如下：<br><br><span class="hljs-keyword">function</span> defineReactive(obj, key, val) &#123;<br>    Object.defineProperty(obj, key, &#123;<br>        <span class="hljs-function"><span class="hljs-title">get</span></span>() &#123;<br>            console.log(`get <span class="hljs-variable">$&#123;key&#125;</span>:<span class="hljs-variable">$&#123;val&#125;</span>`);<br>            <span class="hljs-built_in">return</span> val<br>        &#125;,<br>        <span class="hljs-built_in">set</span>(newVal) &#123;<br>            <span class="hljs-keyword">if</span> (newVal !== val) &#123;<br>                console.log(`<span class="hljs-built_in">set</span> <span class="hljs-variable">$&#123;key&#125;</span>:<span class="hljs-variable">$&#123;newVal&#125;</span>`);<br>                val = newVal<br>            &#125;<br>        &#125;<br>    &#125;)<br>&#125;<br>(2)Object.assign()<br>直接使用Object.assign()添加到对象的新属性不会触发更新<br><br>应创建一个新的对象，合并原对象和混入对象的属性<br><br>this.someObject = Object.assign(&#123;&#125;,this.someObject,&#123;newProperty1:1,newProperty2:2 ...&#125;)<br>个人觉得这种浅拷贝的方法最好。<br><br>(3)<span class="hljs-variable">$forceUpdate</span><br><br>如果你发现你自己需要在 Vue中做一次强制更新，99.9% 的情况，是你在某个地方做错了事<br><br><span class="hljs-variable">$forceUpdate</span>迫使Vue 实例重新渲染<br><br>PS：仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。<br></code></pre></td></tr></table></figure><h3 id="3-vue2与vue3的区别？"><a href="#3-vue2与vue3的区别？" class="headerlink" title="3.vue2与vue3的区别？"></a>3.vue2与vue3的区别？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.双向数据绑定原理不同<br>Vue2 的双向数据绑定是利用ES5的一个APIObject.definePropert() 对数据进行劫持，结合发布订阅模式的方式来实现的。<br><br>Vue3 中使用ES6的Proxy API对数据代理。<br><br>Vue3 使用数据代理的优势有以下几点：1）definePropert 只能监听某个属性，不能对整个对象进行监听 2）可以省去<span class="hljs-keyword">for</span> <span class="hljs-keyword">in</span>，闭包等内容来提升效率（直接绑定整个对象即可）3）可以监听数组，不用再单独的对数组做特异性操作，Vue3可以检测到数组内部数据的变化<br><br>2.是否支持碎片<br>Vue2 不支持碎片。Vue3 支持碎片，就是说可以拥有多个根节点<br><br>3.API 类型不同<br>Vue2 使用选项类型api,选项型api 在代码里分割了不同的属性：data,computed,method等。<br><br>Vue3 使用合成型api,新的合成型api 能让我们使用方法来分割，相比于旧的api 使用属性来分组，这样代码会更加简便和整洁。<br><br>4定义数据变量和方法不同<br>Vue2是把数据放到了data 中，在 Vue2中 定义数据变量是<span class="hljs-function"><span class="hljs-title">data</span></span>()&#123;&#125;,创建的方法要在method:&#123;&#125;<br><br>Vue3 就需要使用一个新的setup()方法，此方法在组件初始化构造的时候触发。使用以下三个步骤来建立反应性数据：1）从vue 引入 reactive；2）使用 reactive ()方法来声明数据为响应性数据；3） 使用setup()方法来返回我们的响应性数据，从而template 可以获取这些响应性数据。<br><br>5.生命周期钩子函数不同<br>Vue2 中的生命周期：beforeCreate 组件创建之前；created 组建创建之后；beforeMount 组件挂载到页面之前执行；Mounted 组件挂载到页面之后执行，beforeUpdate 组件更新之前；updated组件更新之后<br><br>Vue3 中的生命周期：setup 开始创建组件；onBeforeMount 组件挂载到页面之前执行；onMounted 组件挂载到页面之后执行；onBeforeUpdate 组件更新之前；onUpdated 组件更新之后；<br><br>而且 Vue3 生命周期在调用前需要先进行引入。除了这些钩子函数外，Vue3 还增加了 onRenderTracked 和onRenderTriggered 函数。<br><br>6.父子传参不同<br>Vue2 父传子，用props ；子传父用事件Emitting Events。在Vue2 中，会调用this<span class="hljs-variable">$emit</span> 然后传入事件名和对象。<br><br>Vue3 父传子，用props;子传父用Emitting Events 。在Vue3 中的setup()中的第一参数content 对象中就有 emit,那么我们只要在setup()接收第二个参数中使用分解对象法取出emit 就可以在setup 方法中随意使用了。<br><br>7.指令与插槽不同<br>Vue2 中使用slot 可以直接使用slot ;v-for 与v-if 在Vue2中优先级高的是v-for 指令，而且不建议一起使用。<br><br>Vue3 中必须是使用v-slot的形式；vue 3中v-for 与v-if ，只会把当前v-if 当作v-for 的一个判断语句，不会相互冲突；<br><br>Vue3 中移除keyCode 作为v-on 的修饰符，当然也不支持config.keyCodes，取而代之的是使用键名来作为事件的修饰符来使用，于是Vue.config.keyCodes 也被弃用了-vue2我们在监听按键事件的时候，是可以通过在事件后面加上按键码来实现监听某一个按键的<br><br>8.Main.js 文件不同<br>Vue2中我们可以使用pototype(原型)的形式去进行操作，引入的是构造函数。<br><br>Vue3 中需要使用结构的形式进行操作，引入的是工厂函数；<br><br>Vue3中app组件中可以没有根标签。<br><br>9.Setup() 函数特性<br><br>setup() 函数接收两个参数：props、context（包含attrs、slots、emit）<br>setup()函数处于生命周期 beforeCreated 两个钩子函数之前<br>执行setup时，组件实例尚未被创建（在setup（）内部，this不会是该活跃实例的引用，即不指向vue 实例，Vue 为了避免我们错误的使用，直接将setup 函数中的this 修改成了undefined）<br>与模版一起使用时，需要返回一个对象<br>因为setup函数中，props时响应式得，当传入新的prop时，它就会被更新，所以不能使用es6解构，因为它会消除 prop得响应性，如果需要解构prop,可以通过使用setup函数中torefs 来完成此操作。<br>在setup（）内使用响应式数据时，需要通过.value 获取<br>从setup（）中返回得对象上得property 返回并且可以在模版中被访问时，它将自动展开为内部值。不需要在模版中追加.value.<br>Setup 函数只能是同步的不能是异步的。<br><br></code></pre></td></tr></table></figure><h3 id="4-vue-里如何获取-data-中数据的初始状态？"><a href="#4-vue-里如何获取-data-中数据的初始状态？" class="headerlink" title="4.vue 里如何获取 data 中数据的初始状态？"></a>4.vue 里如何获取 data 中数据的初始状态？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">const &#123;list,paging&#125; = this.<span class="hljs-variable">$options</span>.data();  // 获取到data初始化数据元素<br>console.log(list); // 初始化为[]<br>paging.keyword = <span class="hljs-string">&#x27;北京大学&#x27;</span>; // 也可以自定义一些初始化<br>Object.assign(this.<span class="hljs-variable">$data</span>, &#123;list,paging&#125;); // 将初始化数据覆盖当前data<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端</title>
    <link href="/2023/01/18/2023-01-18-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%982/"/>
    <url>/2023/01/18/2023-01-18-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%982/</url>
    
    <content type="html"><![CDATA[<h3 id="1-什么是浏览器缓存机制？"><a href="#1-什么是浏览器缓存机制？" class="headerlink" title="1.什么是浏览器缓存机制？"></a>1.什么是浏览器缓存机制？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">1、Memory Cache<br>内存缓存是一种比较特殊的缓存，他不受 max-age、no-cache 等配置的影响，即使我们不设置缓存，如果当前的内存空间比较充裕的话，一些资源还是会被缓存下来。但这种缓存是暂时的，一旦关闭了浏览器，这一部分用于缓存的内存空间就会被释放掉。如果真的不想使用缓存，可以设置 no-store，这样，即便是内存缓存，也不会生效。<br><br>内存缓存虽然比较高效，但还是受限于计算机内存的大小，所以能让我们使用的内存并不多，这个时候就需要硬盘来存储大量的缓存。.<br><br>2、Disk Cache<br>Disk Cache 也就是存储在硬盘中的缓存。相比较内存缓存的优势就是长时效。<br><br>它会根据HTTP Header中设置的字段类型，来判断资源是否需要重新请求。<br><br>如果当前内存使用率高的话，请求资源大概率会被缓存到disk cache。<br></code></pre></td></tr></table></figure><h3 id="2-webpack配置项是什么？"><a href="#2-webpack配置项是什么？" class="headerlink" title="2.webpack配置项是什么？"></a>2.webpack配置项是什么？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs bash">配置：<br>moudule.exports = &#123;<br>    //首先是入口<br>    entry:<span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>    //配置生成js的文件名<br>    output:&#123;<br>        filename:<span class="hljs-string">&#x27;main.js&#x27;</span><br>    &#125;,<br>    //配置引入文件可以省略的后缀<br>    //例如 import xxx.js from dsadas  == import xxx from dsadas<br>    resolve:&#123;<br>      extensions:[<span class="hljs-string">&#x27;.ts&#x27;</span>,<span class="hljs-string">&#x27;.tsx&#x27;</span>,<span class="hljs-string">&#x27;.js&#x27;</span>]<br>    &#125;,<br>    //配置module，用于模块的读取<br>    module:&#123;<br>        //以下配置的就是关于ts的读取 <br>        rules:[&#123;<br>            <span class="hljs-built_in">test</span>:/\.tsx?$/,<br>            use:<span class="hljs-string">&#x27;ts-loader&#x27;</span>,<br>            exclude:/node_modules/<br>        &#125;]<br>    &#125;,<br>    //配置dev-server<br>    devServer:&#123;<br>        //端口<br>        port:8090,<br>        //是否压缩<br>        compress:<span class="hljs-literal">false</span>,<br>        //主机配置<br>        host:<span class="hljs-string">&#x27;localhost&#x27;</span>,<br>        //打包生成的静态目录<br>        contentBase:<span class="hljs-string">&#x27;./dist&#x27;</span>,<br>        //stats 只打印错误信息<br>        stats:<span class="hljs-string">&#x27;errors-only&#x27;</span><br>    &#125;,<br>    //配置插件 plugins ,主要用到的插件在这里面配置<br>    plugins:&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-JS运行机制以及微宏任务区别？"><a href="#3-JS运行机制以及微宏任务区别？" class="headerlink" title="3.JS运行机制以及微宏任务区别？"></a>3.JS运行机制以及微宏任务区别？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">概念  <br>1. 宏任务：当前调用栈中执行的代码成为宏任务。（主代码快，定时器等等）。 <br><br>2.微任务： 当前（此次事件循环中）宏任务执行完，在下一个宏任务开始之前需要执行的任务,可以理解为回调事件。（promise.then，proness.nextTick等等）。 3. 宏任务中的事件放在callback queue中，由事件触发线程维护；微任务的事件放在微任务队列中，由js引擎线程维护。<br><br>js执行顺序，（先执行宏任务列，微任务队列），<br><br><br>运行机制<br>1. 在执行栈中执行一个宏任务。 <br><br>2. 执行过程中遇到微任务，将微任务添加到微任务队列中。<br><br>3. 当前宏任务执行完毕，立即执行微任务队列中的任务。 <br><br>4. 当前微任务队列中的任务执行完毕，检查渲染，GUI线程接管渲染。 <br><br>5. 渲染完毕后，js线程接管，开启下一次事件循环，执行下一次宏任务（事件队列中取）。<br><br>微任务：process.nextTick、MutationObserver、Promise.<span class="hljs-keyword">then</span> catch finally<br><br>宏任务：I/O、setTimeout、setInterval、setImmediate、requestAnimationFrame<br><br>js执行顺序，（先执行宏任务列，微任务队列），<br></code></pre></td></tr></table></figure><h3 id="4-什么是javascript垃圾回收机制原理？"><a href="#4-什么是javascript垃圾回收机制原理？" class="headerlink" title="4.什么是javascript垃圾回收机制原理？"></a>4.什么是javascript垃圾回收机制原理？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">一、标记清除<br>标记清除（Mark-and-Sweep）的工作原理是：垃圾回收器会定期扫描内存中的对象，从根对象开始遍历内存中的所有对象，对于可达对象，通过标记它们来标识它们是可达对象；对于未被标记的对象，就说明它们是不可达对象，需要被清除。该算法的优点是可以处理循环引用的情况，但在执行时间上可能会比较长，影响程序的性能。<br>例如，有一个对象A，其中包含一个指向对象B的引用，而对象B也包含一个指向对象A的引用。此时，如果我们不手动清除这两个对象，垃圾回收器就会通过标记清除算法自动识别这两个对象并清除它们。<br><br>实现标记清除（Mark-and-Sweep）算法的主要步骤如下：<br><br>创建一个根对象，例如window对象；<br>遍历根对象及其所有引用的对象，并标记它们是可达对象；<br>遍历内存中所有对象，如果发现某个对象未被标记，就将其清除。<br>在JavaScript中，标记清除算法是由浏览器自动完成的，开发者无需手动实现。<br>二、引用计数<br>引用计数（Reference Counting）的工作原理是：垃圾回收器会记录每个对象被引用的次数，当对象被引用的次数为0时，就将该对象清除。该算法的优点是实现较为简单，但无法处理循环引用的情况，可能会导致内存泄漏。<br>例如，有一个对象A，其中包含一个指向对象B的引用，而对象B也包含一个指向对象A的引用。此时，由于对象A和B互相引用的次数不为0，垃圾回收器就无法清除这两个对象，导致内存泄漏。<br><br>实现引用计数（Reference Counting）算法的主要步骤如下：<br>给每个对象添加一个引用计数器，初始值为0；<br>当对象被引用时，引用计数器加1；<br>当对象不再被引用时，引用计数器减1；<br>当引用计数器为0时，就将该对象清除。<br>在JavaScript中，引用计数算法也是由浏览器自动完成的，开发者无需手动实现。不过需要注意的是，由于引用计数无法处理循环引用的情况，因此现代浏览器一般采用标记清除算法。<br></code></pre></td></tr></table></figure><h3 id="5-什么是JS作用域链？"><a href="#5-什么是JS作用域链？" class="headerlink" title="5.什么是JS作用域链？"></a>5.什么是JS作用域链？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">fn</span></span>() &#123;<br>         var a = 30;<br><br>         <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">fm</span></span>() &#123;<br>             var b = 20;<br>             console.log(a);<br>         &#125;<br>         fm();<br>　　　　　　　console.dir(fm);<br>     &#125;<br>     fn();<br>     console.dir(fn);<br></code></pre></td></tr></table></figure><h3 id="6-什么是JS的原型和原型链？"><a href="#6-什么是JS的原型和原型链？" class="headerlink" title="6.什么是JS的原型和原型链？"></a>6.什么是JS的原型和原型链？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs bash">原型：所有的函数默认都有一个“prototype”这样公有且不可枚举的属性，它会指向另一个对象，这个对象就是原型。每当定义一个对象（函数也是对象）时，就会生成一个__proto__属性，被称为隐式原型；这个__proto__属性指向的是这个对象的构造函数的prototype，被称为显式原型。每一个对象都会从原型中“继承”属性。<br>class Student&#123;<br>    constructor(name, score) &#123;<br>        this.name = name;<br>        this.score = score;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">introduce</span></span>() &#123;<br>        console.log(`我是<span class="hljs-variable">$&#123;this.name&#125;</span>，考了<span class="hljs-variable">$&#123;this.score&#125;</span>分。`)<br>    &#125;<br>&#125;<br>const student = new Student(<span class="hljs-string">&#x27;张三&#x27;</span>, 99)<br>console.log(<span class="hljs-string">&#x27;student&#x27;</span>, student); // student Student &#123; name: <span class="hljs-string">&#x27;张三&#x27;</span>, score: 99&#125;<br>student.introduce(); // 我是张三，考了99分。<br>原型链：当访问一个对象的属性或方法时，首先对象会从自身去找，如果找不到，就会往原型中去找，即__proto__，也就是它构造函数的prototype中；如果原型中找不到，即构造函数中也没有该属性，因为构造函数也是对象，也有__proto__，就会往原型上去找，这样就形成了链式的结构，称为原型链，本质描述的是对象的一种继承关系。<br>class Person &#123;<br>    constructor(name) &#123;<br>        this.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">drink</span></span>()&#123;<br>        console.log(<span class="hljs-string">&#x27;喝水&#x27;</span>);<br>    &#125;<br>&#125;<br>class Teacher extends Person &#123;<br>    constructor(name, subject) &#123;<br>        super(name);<br>        this.subject = subject;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">teach</span></span>() &#123;<br>        console.log(`我是<span class="hljs-variable">$&#123;this.name&#125;</span>， 教<span class="hljs-variable">$&#123;this.subject&#125;</span>。`)<br>    &#125;<br>&#125;<br>const teacher = new Teacher(<span class="hljs-string">&#x27;哈默&#x27;</span>, <span class="hljs-string">&#x27;前端开发&#x27;</span>)<br>console.log(<span class="hljs-string">&#x27;teacher&#x27;</span>, teacher);<br>teacher.teach();<br>teacher.drink();<br></code></pre></td></tr></table></figure><h3 id="7-什么是堆与栈？深浅拷贝的理解？"><a href="#7-什么是堆与栈？深浅拷贝的理解？" class="headerlink" title="7.什么是堆与栈？深浅拷贝的理解？"></a>7.什么是堆与栈？深浅拷贝的理解？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs bash">一、栈和堆<br>栈(stack)：栈会自动分配内存空间，会自动释放，存放基本类型，简单的数据段，占据固定大小的空间。<br>基本类型：String，Number，Boolean，Null，Undefined, BigInt, Symbol<br><br>堆(heap):动态分配的内存，大小不定也不会自动释放，存放引用类型，指那些可能由多个值构成的对象，保存在堆内存中，包含引用类型的变量，实际上保存的不是变量本身，而是指向该对象的指针。<br>引用类型：Function，Array，Object<br><br>二、浅拷贝与深拷贝<br>1、 浅拷贝：如果拷贝源对象是基本类型，则拷贝的是值；如果拷贝源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。<br><br>基本类型的浅拷贝：<br>    <span class="hljs-built_in">let</span> arr1 = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>];<br>      <span class="hljs-built_in">let</span> arr2 = [];<br>      arr2.forEach((item,index)=&gt;&#123;<br>          arr2[index] = item;<br>      &#125;);<br>      console.log(arr1); //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]<br>      console.log(arr2); //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]<br><br>引用类型的浅拷贝：<br>    let oldStudent = &#123;<br>        name: &#x27;xiaoMing&#x27;,<br>        age: <span class="hljs-number">18</span>,<br>        habits: [&#x27;swimming&#x27;, &#x27;reading&#x27;, &#x27;shopping&#x27;]<br>      &#125;<br>      let newStudent = oldStudent<br>      newStudent.name = &#x27;sky&#x27;<br>      console.log(oldStudent, &#x27;----oldStudent&#x27;)<br>    &#125;<br><br>result: oldStudent 对象也发生了变化。<br><br><br>结论：浅拷贝的源对象是引用类型时，拷贝的是值的引用，实际上指向的是同一个对象；当对象发生变化时，会同时产生变化。<br><br><span class="hljs-number">2</span>、 深拷贝：对属性中所有引用类型的值，遍历到是基本类型的值为止。<br><br>三、优缺点<br>浅拷贝：<br>优点：存取速度比堆快，仅次于直接位于CPU中的寄存器，数据可以共享；<br>缺点：存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。<br>深拷贝：<br>堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用(参数传递)。创建对象是为了反复利用，这个对象将被保存到运行时数据区。<br></code></pre></td></tr></table></figure><h3 id="8-JS继承"><a href="#8-JS继承" class="headerlink" title="8.JS继承"></a>8.JS继承</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs bash">方法一：原型链继承<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">SuperType</span></span>()&#123;this.property = <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">Type</span></span>()&#123;this.typeproperty = <span class="hljs-literal">false</span><br>&#125;<br>var instance = new Type()<br>console.log(instance.property) <br><br>方法二：经典继承（伪造对象）<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">SuperType</span></span>()&#123;this.property = <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">Type</span></span>()&#123;this.typeproperty = <span class="hljs-literal">false</span><br>&#125;<br>var instance = new Type()<br>console.log(instance.property) <br><br>方法三：组合继承（伪经典继承）<br>组合继承是一种由原型链继承及经典继承的组合起来的继承方式，既解决了原型链继承里的不能传参的弊端，又解决了经典继承里不能继承到原型链上的属性方法的弊端。<br><br>代码如下：<br><span class="hljs-keyword">function</span> SuperType(age)&#123;this.color = <span class="hljs-string">&#x27;red&#x27;</span>;this.age = age;<br>&#125;<br>SuperType.prototype.name = <span class="hljs-string">&#x27;阿轩&#x27;</span>;<br><span class="hljs-keyword">function</span> Type(age)&#123;SuperType.call(this,age);//绑定this<br>&#125;<br>Type.prototype = new SuperType();//将父类实例对象绑定到子类原型上<br>Type.prototype.constructor = Type//弥补因为重写原型而没有构造器属性的缺陷<br>var instance = new Type(18);<br><br>console.log(instance.color)<br>console.log(instance.name)<br>console.log(instance.age)<br><br>方法四：原型式继承<br>这是一种跟原型链继承相似的继承方式，通过名字也是能看出来它们是有关联的。<br>讲到原型式继承，那么我们就要讲到一个创建对象的方法了，它就是： Object.create() 方法。<br>可能大家都知道 Object.create() 方法可以创建对象，可你们知道吗，它还可以让创建出来的对象继承到其它对象的属性方法。<br>那么，让我们看到如下代码吧：<br>var person = &#123;name:<span class="hljs-string">&#x27;阿轩&#x27;</span>,age:<span class="hljs-string">&#x27;20&#x27;</span>,<br>&#125;<br>var obj = Object.create(person);<br>console.log(obj); <br><br>方法五：寄生式继承<br>寄生式继承是原型式继承的功能添加版，它给原型式继承方法添加了一个功能，就是可以往对象上额外添加属性方法；<br>但是说到底，其实只是在 object.create() 方法身上嵌套一层函数，然后在函数里添加方法罢了。<br>如代码：<br><span class="hljs-keyword">function</span> js(obj)&#123;<span class="hljs-built_in">let</span> <span class="hljs-built_in">clone</span> = Object.create(obj);clone.say = () =&gt;&#123;console.log(<span class="hljs-string">&#x27;新增添的可调用函数&#x27;</span>)&#125;<br>&#125;<br>var person = &#123;name:<span class="hljs-string">&#x27;阿轩&#x27;</span>,age:<span class="hljs-string">&#x27;20&#x27;</span>,like:&#123;sport:<span class="hljs-string">&#x27;singing&#x27;</span>&#125;<br>&#125;<br>var obj2 = js(person); <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jekyll搭建个人博客</title>
    <link href="/2021/10/14/2021-10-14-jekyll_tutorials1/"/>
    <url>/2021/10/14/2021-10-14-jekyll_tutorials1/</url>
    
    <content type="html"><![CDATA[<p>　之前写了一篇<a href="http://boobar.cn/2015/08/HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">HEXO搭建个人博客</a>的教程获得了很好评，尤其是在<a href="http://www.jianshu.com/p/465830080ea9">简书</a>上目前已经累积了10W+的阅读量了，也有好心的读者主动给我打赏，在此感谢。</p><p>　如果你看过我的文章会发现我现在的博客样式跟之前是有很大的区别的，之前我也是使用 HEXO 搭建的博客，后来发现使用 HEXO 在多台电脑上发布博客，操作起来并不是那么方便，果断就转到了 Jekyll 上，接下来我会讲如何使用 Jekyll 搭建博客，<a href="http://boobar.cn/#blog">博客模板效果</a>。</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p> 　Jekyll 是一个简单的博客形态的静态站点生产机器。它有一个模版目录，其中包含原始文本格式的文档，通过 Markdown （或者 Textile） 以及 Liquid 转化成一个完整的可发布的静态网站，你可以发布在任何你喜爱的服务器上。Jekyll 也可以运行在 GitHub Page 上，也就是说，你可以使用 GitHub 的服务来搭建你的项目页面、博客或者网站，而且是完全免费的</p><p>　使用 Jekyll 搭建博客之前要确认下本机环境，Git 环境（用于部署到远端）、<a href="http://www.ruby-lang.org/en/downloads/">Ruby</a> 环境（Jekyll 是基于 Ruby 开发的）、包管理器 <a href="http://rubygems.org/pages/download">RubyGems</a><br>　　如果你是 Mac 用户，你就需要安装 Xcode 和 Command-Line Tools了。下载方式 Preferences → Downloads → Components。</p><p>　　Jekyll 是一个免费的简单静态网页生成工具，可以配合第三方服务例如： Disqus（评论）、多说(评论) 以及分享 等等扩展功能，Jekyll 可以直接部署在 Github（国外） 或 Coding（国内） 上，可以绑定自己的域名。<a href="http://jekyll.bootcss.com/">Jekyll中文文档</a>、<a href="https://jekyllrb.com/">Jekyll英文文档</a>、<a href="http://jekyllthemes.org/">Jekyll主题列表</a>。</p><h3 id="Jekyll-环境配置"><a href="#Jekyll-环境配置" class="headerlink" title="Jekyll 环境配置"></a>Jekyll 环境配置</h3><p>安装 jekyll</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">$ gem install jekyll     <br>```    <br><br>创建博客<br><br>```    <br>$ jekyll <span class="hljs-keyword">new</span> myBlog    <br>```   <br><br>进入博客目录<br><br></code></pre></td></tr></table></figure><p>$ cd myBlog  </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs"><br>启动本地服务<br><br></code></pre></td></tr></table></figure><p>$ jekyll serve</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>在浏览器里输入： [http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">4000</span>](http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">4000</span>)，就可以看到你的博客效果了。<br><br>![](<span class="hljs-regexp">/images/</span>posts<span class="hljs-regexp">/jekyll/im</span>age1.png)<br><br>so easy !<br><br><span class="hljs-comment">### 目录结构</span><br>　<br>　Jekyll 的核心其实是一个文本转换引擎。它的概念其实就是： 你用你最喜欢的标记语言来写文章，可以是 Markdown，也可以是 Textile,或者就是简单的 HTML, 然后 Jekyll 就会帮你套入一个或一系列的布局中。在整个过程中你可以设置URL路径, 你的文本在布局中的显示样式等等。这些都可以通过纯文本编辑来实现，最终生成的静态页面就是你的成品了。<br><br> 一个基本的 Jekyll 网站的目录结构一般是像这样的：<br><br></code></pre></td></tr></table></figure><p>.<br>├── _config.yml<br>├── _includes<br>|   ├── footer.html<br>|   └── header.html<br>├── _layouts<br>|   ├── default.html<br>|   ├── post.html<br>|   └── page.html<br>├── _posts<br>|   └── 2016-10-08-welcome-to-jekyll.markdown<br>├── _sass<br>|   ├── _base.scss<br>|   ├── _layout.scss<br>|   └── _syntax-highlighting.scss<br>├── about.md<br>├── css<br>|   └── main.scss<br>├── feed.xml<br>└── index.html</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>这些目录结构以及具体的作用可以参考 [官网文档](http:<span class="hljs-regexp">//</span>jekyll.com.cn<span class="hljs-regexp">/docs/</span>structure/) <br><br>进入 _config.yml 里面，修改成你想看到的信息，重新 jekyll server ，刷新浏览器就可以看到你刚刚修改的信息了。<br><br>到此，博客初步搭建算是完成了，<br><br><span class="hljs-comment">### 博客部署到远端 </span><br><br>　我这里讲的是部署到 Github Page 创建一个 github 账号，然后创建一个跟你账户名一样的仓库，如我的 github 账户名叫 [boobar](https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/boobar)，我的 github 仓库名就叫 [boobar.github.io](https:/</span><span class="hljs-regexp">/github.com/</span>boobar/boobar.github.io)，创建好了之后，把刚才建立的 myBlog 项目 push 到 username.github.io仓库里去（username指的是你的github用户名），检查你远端仓库已经跟你本地 myBlog 同步了，然后你在浏览器里输入 username.github.io ，就可以访问你的博客了。<br><br><br><span class="hljs-comment">### 编写文章</span><br><br>　　所有的文章都是 _posts 目录下面，文章格式为 mardown 格式，文章文件名可以是 .mardown 或者 .md。<br><br>　　编写一篇新文章很简单，你可以直接从 _posts<span class="hljs-regexp">/ 目录下复制一份出来 `2016-10-16-welcome-to-jekyll副本.markdown` ，修改名字为 2016-10-16-article1.markdown ，注意：文章名的格式前面必须为 2016-10-16- ，日期可以修改，但必须为 年-月-日- 格式，后面的 article1 是整个文章的连接 URL，如果文章名为中文，那么文章的连接URL就会变成这样的：http:/</span><span class="hljs-regexp">/boobar.cn/</span><span class="hljs-number">2015</span><span class="hljs-regexp">/08/</span>%E6%<span class="hljs-number">90</span>%AD%E5/ ， 所以建议文章名最好是英文的或者阿拉伯数字。 双击 <span class="hljs-number">2016</span>-<span class="hljs-number">10</span>-<span class="hljs-number">16</span>-article1.markdown 打开<br><br></code></pre></td></tr></table></figure><hr><h2 id="layout-posttitle-“Welcome-to-Jekyll-”date-2021-10-16-11-29-08-0800categories-jekyll-update"><a href="#layout-posttitle-“Welcome-to-Jekyll-”date-2021-10-16-11-29-08-0800categories-jekyll-update" class="headerlink" title="layout: posttitle:  “Welcome to Jekyll!”date:   2021-10-16 11:29:08 +0800categories: jekyll update"></a>layout: post<br>title:  “Welcome to Jekyll!”<br>date:   2021-10-16 11:29:08 +0800<br>categories: jekyll update</h2><p>正文…</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br><br>title: 显示的文章名， 如：title: 我的第一篇文章                    <br>date:  显示的文章发布日期，如：date: <span class="hljs-number">2021</span>-<span class="hljs-number">10</span>-<span class="hljs-number">16</span>                          <br>categories: tag标签的分类，如：categories: 随笔            <br><br>注意：文章头部格式必须为上面的，.... 就是文章的正文内容。<br><br>我写文章使用的是 Sublime Text2 编辑器，如果你对 markdown 语法不熟悉的话，可以看看[作业部落的教程](https:<span class="hljs-regexp">//</span>www.zybuluo.com/) <br><br><br><span class="hljs-comment">### 使用我的博客模板</span><br><br>虽然博客部署完成了，你会发现博客太简单不是你想要的，如果你喜欢我的模板的话，可以使用我的模板。<br><br>首先你要获取的我博客，[Github项目地址](https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/boobar/</span>boobar.github.io.git)，你可以直接[点击下载博客](https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/boobar/</span>boobar.github.io<span class="hljs-regexp">/archive/m</span>aster.zip)，进去boobar.github.io/ 目录下， 使用命令部署本地服务 <br><br></code></pre></td></tr></table></figure><p>$ jekyll server   </p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>### 如果你本机没配置过任何jekyll的环境，可能会报错<br><br></code></pre></td></tr></table></figure><p>&#x2F;Users&#x2F;xxxxxxxx&#x2F;.rvm&#x2F;rubies&#x2F;ruby-2.2.2&#x2F;lib&#x2F;ruby&#x2F;site_ruby&#x2F;2.2.0&#x2F;rubygems&#x2F;core_ext&#x2F;kernel_require.rb:54:in <code>require&#39;: cannot load such file -- bundler (LoadError)     from /Users/xxxxxxxx/.rvm/rubies/ruby-2.2.2/lib/ruby/site_ruby/2.2.0/rubygems/core_ext/kernel_require.rb:54:in </code>require’<br>    from &#x2F;Users&#x2F;xxxxxxxx&#x2F;.rvm&#x2F;gems&#x2F;ruby-2.2.2&#x2F;gems&#x2F;jekyll-3.3.0&#x2F;lib&#x2F;jekyll&#x2F;plugin_manager.rb:34:in <code>require_from_bundler&#39;     from /Users/xxxxxxxx/.rvm/gems/ruby-2.2.2/gems/jekyll-3.3.0/exe/jekyll:9:in </code>&lt;top (required)&gt;’<br>    from &#x2F;Users&#x2F;xxxxxxxx&#x2F;.rvm&#x2F;gems&#x2F;ruby-2.2.2&#x2F;bin&#x2F;jekyll:23:in <code>load&#39;     from /Users/xxxxxxxx/.rvm/gems/ruby-2.2.2/bin/jekyll:23:in </code><main>‘<br>    from &#x2F;Users&#x2F;xxxxxxxx&#x2F;.rvm&#x2F;gems&#x2F;ruby-2.2.2&#x2F;bin&#x2F;ruby_executable_hooks:15:in <code>eval&#39;     from /Users/xxxxxxxx/.rvm/gems/ruby-2.2.2/bin/ruby_executable_hooks:15:in </code><main>‘</main></main></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><br>原因： 没有安装 <span class="hljs-keyword">bundler </span>，执行安装 <span class="hljs-keyword">bundler </span>命令<br><br></code></pre></td></tr></table></figure><p>$ gem install bundler</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br>提示： <br><br></code></pre></td></tr></table></figure><p>Fetching: bundler-1.13.5.gem (100%)<br>Successfully installed bundler-1.13.5<br>Parsing documentation for bundler-1.13.5<br>Installing ri documentation for bundler-1.13.5<br>Done installing documentation for bundler after 5 seconds<br>1 gem installed</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><br>再次执行 $ jekyll <span class="hljs-keyword">server</span>  ，提示<br><br></code></pre></td></tr></table></figure><p>Could not find proper version of jekyll (3.1.1) in any of the sources<br>Run <code>bundle install</code> to install missing gems.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs"><br>跟着提示运行命令<br><br></code></pre></td></tr></table></figure><p>$ bundle install</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><br>这个时候你可能会发现 <span class="hljs-keyword">bundle </span><span class="hljs-keyword">install </span>运行卡主不动了。<br><br>如果很长时间都没任何提示的话，你可以尝试修改 gem 的 source<br><br></code></pre></td></tr></table></figure><p>$ gem sources –remove <a href="https://rubygems.org/">https://rubygems.org/</a><br>$ gem sources -a <a href="http://ruby.taobao.org/">http://ruby.taobao.org/</a><br>$ gem sources -l<br>*** CURRENT SOURCES ***</p><p><a href="http://ruby.taobao.org/">http://ruby.taobao.org</a></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><br>再次执行命令 $ <span class="hljs-keyword">bundle </span><span class="hljs-keyword">install，发现开始有动静了</span><br><span class="hljs-keyword"></span><br></code></pre></td></tr></table></figure><p>Fetching gem metadata from <a href="https://rubygems.org/">https://rubygems.org/</a>………..<br>Fetching version metadata from <a href="https://rubygems.org/">https://rubygems.org/</a>..<br>Fetching dependency metadata from <a href="https://rubygems.org/">https://rubygems.org/</a>.<br>。。。<br>Installing jekyll-watch 1.3.1<br>Installing jekyll 3.1.1<br>Bundle complete! 3 Gemfile dependencies, 17 gems now installed.<br>Use <code>bundle show [gemname]</code> to see where a bundled gem is installed.</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><br><span class="hljs-keyword">bundler安装完成，后再次启动本地服务 </span><br><br></code></pre></td></tr></table></figure><p>$ jekyll server</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs"><br>继续报错<br><br></code></pre></td></tr></table></figure><p>Configuration file: &#x2F;Users&#x2F;tendcloud-Caroline&#x2F;Desktop&#x2F;boobar.github.io&#x2F;_config.yml<br>  Dependency Error: Yikes! It looks like you don’t have jekyll-sitemap or one of its dependencies installed. In order to use Jekyll as currently configured, you’ll need to install this gem. The full error message from Ruby is: ‘cannot load such file – jekyll-sitemap’ If you run into trouble, you can find helpful resources at <a href="http://jekyllrb.com/help/">http://jekyllrb.com/help/</a>!<br>jekyll 3.1.1 | Error:  jekyll-sitemap</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">表示 当前的 <span class="hljs-keyword">jekyll </span>版本是 <span class="hljs-number">3</span>.<span class="hljs-number">1</span>.<span class="hljs-number">1</span> ，无法使用 <span class="hljs-keyword">jekyll-sitemap </span><br><br>解决方法有两个<br><br>&gt; <span class="hljs-number">1</span>、打开当前目录下的 _<span class="hljs-built_in">config</span>.yml 文件，把 gems: [<span class="hljs-keyword">jekyll-paginate,jekyll-sitemap] </span>换成 gems: [<span class="hljs-keyword">jekyll-paginate] </span>，也就是去掉<span class="hljs-keyword">jekyll-sitemap。</span><br><span class="hljs-keyword"></span><br>&gt; <span class="hljs-number">2</span>、升级 <span class="hljs-keyword">jekyll </span>版本，我当前的是 <span class="hljs-keyword">jekyll </span><span class="hljs-number">3</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span> 。<br><br>修改完成后保存配置，再次执行<br><br></code></pre></td></tr></table></figure><p>$ jekyll server</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">提示<br><br></code></pre></td></tr></table></figure><p>Configuration file: &#x2F;Users&#x2F;baixinpan&#x2F;Desktop&#x2F;OpenSource&#x2F;Mine&#x2F;Page-Blog&#x2F;boobar.github.io-github&#x2F;_config.yml<br>            Source: &#x2F;Users&#x2F;baixinpan&#x2F;Desktop&#x2F;OpenSource&#x2F;Mine&#x2F;Page-Blog&#x2F;boobar.github.io-github<br>       Destination: &#x2F;Users&#x2F;baixinpan&#x2F;Desktop&#x2F;OpenSource&#x2F;Mine&#x2F;Page-Blog&#x2F;boobar.github.io-github&#x2F;_site<br> Incremental build: disabled. Enable with –incremental<br>      Generating…<br>                    done in 0.901 seconds.<br> Auto-regeneration: enabled for ‘&#x2F;Users&#x2F;baixinpan&#x2F;Desktop&#x2F;OpenSource&#x2F;Mine&#x2F;Page-Blog&#x2F;boobar.github.io-github’<br>Configuration file: &#x2F;Users&#x2F;baixinpan&#x2F;Desktop&#x2F;OpenSource&#x2F;Mine&#x2F;Page-Blog&#x2F;boobar.github.io-github&#x2F;_config.yml<br>    Server address: <a href="http://127.0.0.1:4000/">http://127.0.0.1:4000/</a><br>  Server running… press ctrl-c to stop.</p><pre><code class="hljs">表示本地服务部署成功。在浏览器输入 [127.0.0.1:4000](127.0.0.1:4000) ， 就可以看到[boobar.cn](http://boobar.cn)博客效果了。### 修改成你自己的博客&gt;* 如果你想使用我的模板请把 _posts/ 目录下的文章都去掉。&gt;* 修改 _config.yml 文件里面的内容为你自己的。然后使用 git push 到你自己的仓库里面去，检查你远端仓库，在浏览器输入 username.github.io 就会发现，你有一个漂亮的主题模板了。      ### 为什么要是用 Jekyll使用了 Jekyll 你会发现如果你想使用多台电脑发博客都很方便，只要把远端 github 仓库里的博客 clone 下来，写文章后再提交就可以了，Hexo 由于远端提交的是静态网页，所有无法直接写 Markdown 的文章。如果你想看 Hexo 搭建博客，可以看看我的另一篇[HEXO搭建个人博客](http://boobar.cn/2015/08/HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/)的教程。如果你在搭建博客遇到问题，可以在[原文博客](http://boobar.cn/2016/10/jekyll_tutorials1/)的评论里给我提问。后面会继续介绍，在我的博客基础上，如何修改成你自己喜欢的 Style，欢迎继续关注我博客的更新。### Q&amp;A &gt; 问题：最近很多朋友使用我的模板报警告：The CNAME `boobar.cn` is already taken &gt; 解决：把CNAME里面的baixin.io修改成你自己的域名，如果你暂时没有域名，CNAME里面就什么都不用谢。（之前没人反馈过这个问题，应该是github page最近才最的限制。）</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>jekyll</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue</title>
    <link href="/2021/09/05/2023-09-05-Vue/"/>
    <url>/2021/09/05/2023-09-05-Vue/</url>
    
    <content type="html"><![CDATA[<h3 id="1-nextTick的使用"><a href="#1-nextTick的使用" class="headerlink" title="1.$nextTick的使用?"></a>1.$nextTick的使用?</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vue中的nextTick主要用于处理数据动态变化后，DOM还未及时更新的问题，用nextTick就可以获取数据更新后最新DOM的变化<br></code></pre></td></tr></table></figure><h3 id="2-v-if与v-show的区别？"><a href="#2-v-if与v-show的区别？" class="headerlink" title="2.v-if与v-show的区别？"></a>2.v-if与v-show的区别？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">1、主要区别<br>（1）“v-show”只编译一次；而“v-if”不停地销毁和创建<br>（2）“v-if”更适合于带有权限的操作，渲染时判断权限数据<br>（3）v-show更适合于日常使用，可以减少数据的渲染，减少不必要的操作<br>2、本质区别<br>（1）vue-show本质就是标签display设置为none，控制隐藏<br>（2）vue-if是动态的向DOM树内添加或者删除DOM元素<br></code></pre></td></tr></table></figure><h3 id="3-《keep-alive》《-keep-alive》的作用是什么？"><a href="#3-《keep-alive》《-keep-alive》的作用是什么？" class="headerlink" title="3.《keep-alive》《&#x2F;keep-alive》的作用是什么？"></a>3.《keep-alive》《&#x2F;keep-alive》的作用是什么？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">keep-alive用来缓存组件,避免多次加载相应的组件,从而减少性能消耗，简单来说就是从页面1链接到其他页面后回退到页面1不用在重新执行页面1的代码，只会从缓存中加载之前已经缓存的页面1，这样可以减少加载时间及性能消耗，提高用户体验性，不会触发该页面的created钩子函数<br></code></pre></td></tr></table></figure><h3 id="4-怎样理解vue的单向数据流？"><a href="#4-怎样理解vue的单向数据流？" class="headerlink" title="4.怎样理解vue的单向数据流？"></a>4.怎样理解vue的单向数据流？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">指数据一般从父组件传到子组件，子组件没有权利直接修改父组件传来的数据，即子组件从 props 中直接获取的数据，只能请求父组件修改数据再传给子组件。父级属性值的更新会下行流动到子组件中。<br></code></pre></td></tr></table></figure><h3 id="5-vue的父组件和子组件生命周期钩子函数执行顺序？"><a href="#5-vue的父组件和子组件生命周期钩子函数执行顺序？" class="headerlink" title="5.vue的父组件和子组件生命周期钩子函数执行顺序？"></a>5.vue的父组件和子组件生命周期钩子函数执行顺序？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">加载渲染过程：<br>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted<br>子组件更新过程：<br>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated<br>父组件更新过程：<br>父 beforeUpdate -&gt; 父 updated<br>销毁过程：<br>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed<br></code></pre></td></tr></table></figure><h3 id="6-vue在那些生命周期内调用异步请求？"><a href="#6-vue在那些生命周期内调用异步请求？" class="headerlink" title="6.vue在那些生命周期内调用异步请求？"></a>6.vue在那些生命周期内调用异步请求？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.created，请求时间早，页面loading时间短；<br>2.mounted，页面渲染完成，可以进行DOM操作；<br></code></pre></td></tr></table></figure><h3 id="7-vue第一次页面加载会触发那几个钩子？"><a href="#7-vue第一次页面加载会触发那几个钩子？" class="headerlink" title="7.vue第一次页面加载会触发那几个钩子？"></a>7.vue第一次页面加载会触发那几个钩子？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">当页面第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子函数<br></code></pre></td></tr></table></figure><h3 id="8-vue-router路由模式有几种以及原理？"><a href="#8-vue-router路由模式有几种以及原理？" class="headerlink" title="8.vue-router路由模式有几种以及原理？"></a>8.vue-router路由模式有几种以及原理？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">hash</span>模式：使用 URL 的 <span class="hljs-built_in">hash</span> 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载，其显示的网路路径中会有 “<span class="hljs-comment">#” 号，有一点点丑。这是最安全的模式，因为他兼容所有的浏览器和服务器。</span><br><span class="hljs-built_in">history</span>模式：美化后的<span class="hljs-built_in">hash</span>模式，会去掉路径中的 “<span class="hljs-comment">#”。依赖于Html5 的history，pushState API,所以要担心IE9以及一下的版本，感觉不用担心。并且还包括back、forward、go三个方法，对应浏览器的前进，后退，跳转操作。就是浏览器左上角的前进、后退等按钮进行的操作。</span><br>原理：<br><span class="hljs-built_in">hash</span>： 监听浏览器 url 上的 <span class="hljs-built_in">hash</span> 值，切换浏览器对应的页面。<br>什么是 <span class="hljs-built_in">hash</span> 值？<span class="hljs-built_in">hash</span> 值是一个可读可写的字符串，该字符串是 URL 的锚部分（从<span class="hljs-comment">#号开始的部分）。可以通过 window.location.hash 获取。</span><br><span class="hljs-built_in">history</span>： 对象包含用户（在浏览器窗口中）访问过的 URL。 History 对象是 window 对象的一部分，可通过 window.history 属性对其进行访问。它表示当前窗口的浏览历史。当页面发生改变时，只会改变页面的路径，不会刷新页面。 所以我们操作 History 对象 就相当于操作浏览器上对应的 url。<br></code></pre></td></tr></table></figure><h3 id="9-怎么定义vue-router的动态路由？怎么获取传过来的值？"><a href="#9-怎么定义vue-router的动态路由？怎么获取传过来的值？" class="headerlink" title="9.怎么定义vue-router的动态路由？怎么获取传过来的值？"></a>9.怎么定义vue-router的动态路由？怎么获取传过来的值？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 动态路径参数，使用 “冒号” 开头，一个路径参数，使用冒号标记，当匹配到一个路由时，参数会被设置到  this.<span class="hljs-variable">$router</span>.params 中,并且可以在每个组件中使用<br>this.<span class="hljs-variable">$router</span>.push(&#123;<br> name:<span class="hljs-string">&quot;路由地址&quot;</span>,<br> params:&#123;<br> name:<span class="hljs-string">&#x27;要发送的数据&#x27;</span>,<br> &#125;<br>&#125;);<br>//读取 路由参数接收<br>this.name = this.<span class="hljs-variable">$route</span>.params.name;<br>2.现在我们知道了 可以通过动态路由传参，在路由中设置了，多段路径参数后，对应的值分别都会设置到  <span class="hljs-variable">$router</span>.query 和 <span class="hljs-variable">$router</span>.params 中<br></code></pre></td></tr></table></figure><h3 id="10-vue常用的修饰符？"><a href="#10-vue常用的修饰符？" class="headerlink" title="10.vue常用的修饰符？"></a>10.vue常用的修饰符？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">.stop 阻止冒泡<br>.prevent 取消事件<br>.capture 事件捕获模式<br>.self 只当在 event.target 是当前元素自身时触发处理函数<br>.once 事件将只会触发一次<br>.passive 告诉浏览器你不想阻止事件的默认行为<br></code></pre></td></tr></table></figure><h3 id="11-vue是如何实现数据双向绑定的？"><a href="#11-vue是如何实现数据双向绑定的？" class="headerlink" title="11.vue是如何实现数据双向绑定的？"></a>11.vue是如何实现数据双向绑定的？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Vue内部通过Object.defineProperty方法属性拦截的方式，把data对象里每个数据的读写转化成getter/setter，当数据变化时通知视图更新<br></code></pre></td></tr></table></figure><h3 id="12-computed和watch的区别和运用场景？"><a href="#12-computed和watch的区别和运用场景？" class="headerlink" title="12.computed和watch的区别和运用场景？"></a>12.computed和watch的区别和运用场景？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">computed：是计算属性，并且computed的值具有缓存，只有他依赖的属性发生变化，下一次获取computed的值才会重新计算属性的值。<br>适用场景：当我们需要进行计算，并且依赖其他数据时，应该使用computed，可以利用computed的缓存特性，避免每次获取值时都要重新计算(购物车计算价格的案例)。<br>watch适合于一个数据影响多个数据，computed：适合于多个变量或者对象进行处理后返回一个结果值<br>watch：(侦听器)没有缓存性，更多的是观察的作用，可以监听某些数据执行回调。当我们需要深度监听对象中的属性时，可以打开deep：<span class="hljs-literal">true</span>选项，这样便会对对象中的每一项进行监听。一个数据影响多个数据。<br>使用场景：在数据变化时执行异步或者开销较大的操作时，应该使用watch。 watch允许异步操作 (比如：浏览器自适应、监控路由对象、监控自身属性变化)。<br></code></pre></td></tr></table></figure><h3 id="13-vue的生命周期函数？"><a href="#13-vue的生命周期函数？" class="headerlink" title="13.vue的生命周期函数？"></a>13.vue的生命周期函数？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">beforeCreate（）创建前<br>created（）创建后<br>beforeMount（）挂载前<br>mounted（）挂载后<br>beforeUpdate（）更改前<br>updated（）更改后<br>beforeDestroy（）销毁前<br>destroy（）销毁后<br></code></pre></td></tr></table></figure><h3 id="14-你是怎么理解vuex？"><a href="#14-你是怎么理解vuex？" class="headerlink" title="14.你是怎么理解vuex？"></a>14.你是怎么理解vuex？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。<br>vuex分为五个大块<br>state： 统一定义公共数据（类似于<span class="hljs-function"><span class="hljs-title">data</span></span>()&#123;<span class="hljs-built_in">return</span> &#123;a:1, b:2，xxxxxx&#125;&#125;）<br>mutations： 使用它来修改数据(类似于methods)<br>getters： 类似于computed(计算属性，对现有的状态进行计算得到新的数据)<br>actions： 发起异步请求<br>modules： 模块拆分<br></code></pre></td></tr></table></figure><h3 id="15-vue2组件通信"><a href="#15-vue2组件通信" class="headerlink" title="15.vue2组件通信"></a>15.vue2组件通信</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.  props 和 <span class="hljs-variable">$emit</span><br>2.  父组件向子组件传递数量通过props传递<br>3.  子组件向父组件传递通过<span class="hljs-variable">$emit</span>派发事件<br>4.  <span class="hljs-variable">$parent</span> <span class="hljs-variable">$children</span><br>5.  中央数据总线EventBus<br>6.  ref 和 <span class="hljs-variable">$refs</span><br>7.  Provide 和 inject<br>8.  listeners<br>9.  Vuex<br></code></pre></td></tr></table></figure><h3 id="16-vue如何调用子组件的方法"><a href="#16-vue如何调用子组件的方法" class="headerlink" title="16.vue如何调用子组件的方法"></a>16.vue如何调用子组件的方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">通过使用<span class="hljs-variable">$refs</span>、事件和<span class="hljs-variable">$parent</span>等方式来实现父组件和子组件的通信<br></code></pre></td></tr></table></figure><h3 id="17-Vue指令"><a href="#17-Vue指令" class="headerlink" title="17.Vue指令"></a>17.Vue指令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">v-model数据绑定<br>v-for  循环   格式  v-for=<span class="hljs-string">&quot;字段名 in(of) 数组json&quot;</span><br>v-show 显示 隐藏     传递的值为布尔值  <span class="hljs-literal">true</span>  <span class="hljs-literal">false</span>  默认为<span class="hljs-literal">false</span><br>v-if   显示与隐藏     和v-show对比的区别 就是是否删除dom节点   默认值为<span class="hljs-literal">false</span><br>v-else-if  必须和v-if连用<br>v-else  必须和v-if连用  不能单独使用  否则报错   模板编译错误<br>v-bind  动态绑定  作用： 及时对页面的数据进行更改<br>v-on   绑定事件  函数必须写在methods里面<br>v-text  解析文本<br>v-html  解析html标签<br></code></pre></td></tr></table></figure><h3 id="18-vue中的data为什么是一个函数"><a href="#18-vue中的data为什么是一个函数" class="headerlink" title="18.vue中的data为什么是一个函数"></a>18.vue中的data为什么是一个函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">在 Vue 中，组件的 data 选项必须是一个函数。这是因为 Vue 在创建组件实例时，会为每个组件实例都创建一个独立的数据作用域，如果将 data 直接定义为一个对象，那么所有组件实例都将共享同一个数据对象，这样就无法实现数据的隔离。<br></code></pre></td></tr></table></figure><h3 id="19-vue项目中watch的配置项分别是哪些？"><a href="#19-vue项目中watch的配置项分别是哪些？" class="headerlink" title="19.vue项目中watch的配置项分别是哪些？"></a>19.vue项目中watch的配置项分别是哪些？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">第一个handler：其值是一个回调函数。即监听到变化时应该执行的函数。<br>第二个是deep：其值是<span class="hljs-literal">true</span>或<span class="hljs-literal">false</span>；确认是否深入监听。（一般监听时是不能监听到对象属性值的变化的，数组的值变化可以听到。）<br>第三个是immediate：其值是<span class="hljs-literal">true</span>或<span class="hljs-literal">false</span>；确认是否以当前的初始值执行handler的函数。<br></code></pre></td></tr></table></figure><h3 id="20-一个vue文件是否可以存在两个watch？"><a href="#20-一个vue文件是否可以存在两个watch？" class="headerlink" title="20.一个vue文件是否可以存在两个watch？"></a>20.一个vue文件是否可以存在两个watch？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">不存在两个watch，可以多处监听<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端</title>
    <link href="/2021/04/15/2021-04-15-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2021/04/15/2021-04-15-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="1-什么是盒子模型？"><a href="#1-什么是盒子模型？" class="headerlink" title="1.什么是盒子模型？"></a>1.什么是盒子模型？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">CSS盒子模型就是在网页设计中经常用到的一种思维模型。是有内容、边框、内边距、外边距组成的。<br></code></pre></td></tr></table></figure><h3 id="2-简单描述一下cookies、sessionStorage、localStorage的区别？"><a href="#2-简单描述一下cookies、sessionStorage、localStorage的区别？" class="headerlink" title="2.简单描述一下cookies、sessionStorage、localStorage的区别？"></a>2.简单描述一下cookies、sessionStorage、localStorage的区别？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失，存储大小为20M。<br>sessionStorage的生命周期是在仅在当前会话下有效。关闭浏览器则自动删除，存储大小为5M。<br>sessionStorage的生命周期是单个cookie保存的数据不能超过4kb，判断用户是否登陆过网站，以便下次登录时能够实现自动登录（或者记住密码）。如果我们删除cookie，则每次登录必须重新填写登录的相关信息。<br>保存上次登录的时间等信息，保存上次查看的页面，浏览计数等。<br></code></pre></td></tr></table></figure><h3 id="3-Cookie和Session的区别"><a href="#3-Cookie和Session的区别" class="headerlink" title="3.Cookie和Session的区别"></a>3.Cookie和Session的区别</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">cookie机制：<br>如果不在浏览器中设置过期时间，cookie被保存在内存中，存储大小为4kb，生命周期随浏览器的关闭而结束，这种cookie简称会话cookie。如果在浏览器中设置了cookie的过期时间，cookie被保存在硬盘中，关闭浏览器后，cookie数据仍然存在，直到过期时间结束才消失。<br>Cookie是服务器发给客户端的特殊信息，cookie是以文本的方式保存在客户端，每次请求时都会带上它！<br>session机制：<br>当服务器收到请求需要创建session对象时，首先会检查客户端请求中是否包含sessionid。如果有sessionid，服务器将根据该<span class="hljs-built_in">id</span>返回对应session对象。如果客户端请求中没有sessionid，服务器会创建新的session对象，并把sessionid在本次响应中返回给客户端。<br><br></code></pre></td></tr></table></figure><h3 id="4-什么是跨域？如何解决跨域问题？"><a href="#4-什么是跨域？如何解决跨域问题？" class="headerlink" title="4.什么是跨域？如何解决跨域问题？"></a>4.什么是跨域？如何解决跨域问题？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">是由于浏览器同源策略限制，同源策略由：https://（协议号 ）  www.baidu.com （域名 ） :8080 (端口号)  /test (路径)<br>解决：1.Proxy代理 （前端解决：只适用于本地开发环境，上线了解决不了，直接把dist放在后端服务器中,Proxy通过服务端接口转发来实现对于跨域问题的问题，因为HTTP同源策略只在浏览器中生效。 这里介绍几种不同Proxy代理方法）<br>2.跨域资源共享 CORS（目前最主流、最简单的方案，直接让后端设置响应头，允许资源共享就ok了）<br>3.JSONP (JSONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，兼容性好（兼容低版本IE），缺点是只支持get请求，不支持post请求。) <br></code></pre></td></tr></table></figure><h3 id="5-什么是MVVM？"><a href="#5-什么是MVVM？" class="headerlink" title="5.什么是MVVM？"></a>5.什么是MVVM？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">MVVM采用双向数据绑定，view中数据变化将自动反映到viewmodel上，反之，model中数据变化也将会自动展示在页面上。把Model和View关联起来的就是ViewModel。ViewModel负责把Model的数据同步到View显示出来，还负责把View的修改同步回Model。 <br></code></pre></td></tr></table></figure><h3 id="6-如何进行网站性能优化？"><a href="#6-如何进行网站性能优化？" class="headerlink" title="6.如何进行网站性能优化？"></a>6.如何进行网站性能优化？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.懒加载 2.css预处理器代码优化 3.减少http请求，合理设置 HTTP缓存  4.CSS放在页面最上部，javascript放在页面最下面 5.代码压缩精灵图 6.防抖节流<br></code></pre></td></tr></table></figure><h3 id="7-js的数据类型"><a href="#7-js的数据类型" class="headerlink" title="7.js的数据类型"></a>7.js的数据类型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">基本数据类型：String、Number、Boolean、Null、Undefined、Symbol、BigInt<br>引用数据类型：object，array，<span class="hljs-keyword">function</span><br></code></pre></td></tr></table></figure><h3 id="8-bind-、-call-、-apply-的区别和作用？"><a href="#8-bind-、-call-、-apply-的区别和作用？" class="headerlink" title="8. .bind()、.call()、.apply()的区别和作用？"></a>8. .bind()、.call()、.apply()的区别和作用？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">相同点:都可以改变this的指向<br>不同点:<br>1.call和apply会调用函数，并且改变函数内部this的指向。<br>2.call和apply传递的参数不一样，call传递的参数列表，apply则是一样数组形式。<br>3.<span class="hljs-built_in">bind</span>不会调用函数，可以改变函数this的指向。<br></code></pre></td></tr></table></figure><h3 id="9-简单说说你对SPA单页面的理解，它的优缺点分别是什么？"><a href="#9-简单说说你对SPA单页面的理解，它的优缺点分别是什么？" class="headerlink" title="9.简单说说你对SPA单页面的理解，它的优缺点分别是什么？"></a>9.简单说说你对SPA单页面的理解，它的优缺点分别是什么？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.简单来说SPA的网页只有一个页面，而这个网页的实际方式要能够回应使用者所使用的各种装置并且赋值使用者在电脑上使用软件的体验，让使用者可以更容易和有效的使用网站。按照正常情况下，我们会在一个页面中链接到其他的很多个页面，进行页面的跳转，但是如果使用单页面应用的话，我们始终在一个页面中，通常使用a标签的描点来实现。<br>优点：<br>1.用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染。<br>2.基于上面一点，SPA相对对服务器压力小。<br>缺点：<br>1.以SPA方式开发的网站不容易管理也不够安全。<br>2.由于所有的内容都在一个页面中动态替换显示，所以在SEO上其有着天然的弱势，所以如果你的站点对SEO很看重，且要用单页应用，那么就做些静态页面给搜索引擎用吧。<br>3.初次加载页面更耗时。<br>4.因为没有换页，所以不能使用浏览器的前进、后退、地址栏等，需要程序进行管理；<br>5.书签，需要程序来提供支持；<br>6.初次加载耗时多。为实现单页Web应用功能及显示效果，需要在加载页面的时候将JavaScript、CSS统一加载，部分页面可以在需要的时候加载。所以必须对JavaScript及CSS代码进行合并压缩处理，如果使用第三方库，建议使用一些大公司的CDN，因此带宽的消耗是必然的。<br></code></pre></td></tr></table></figure><h3 id="10-js的深浅拷贝？"><a href="#10-js的深浅拷贝？" class="headerlink" title="10.js的深浅拷贝？"></a>10.js的深浅拷贝？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash">深度：在JavaScript 中使用JSON.parse()和JSON.stringify()深度克隆对象与数组（正则与new <span class="hljs-built_in">date</span>()除外）<br>//使用递归的方式实现数组、对象的深拷贝<br><span class="hljs-built_in">export</span> <span class="hljs-keyword">function</span> deepClone (obj) &#123;<br>    <span class="hljs-built_in">let</span> objClone = Array.isArray(obj) ? [] : &#123;&#125;;<br>    <span class="hljs-keyword">if</span> (obj &amp;&amp; typeof obj === <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>        <span class="hljs-keyword">for</span> (var key <span class="hljs-keyword">in</span> obj) &#123;<br>            <span class="hljs-keyword">if</span> (obj.hasOwnProperty(key)) &#123;<br>                //判断ojb子元素是否为对象，如果是，递归复制<br>                <span class="hljs-keyword">if</span> (obj[key] &amp;&amp; typeof obj[key] === <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>                    objClone[key] = deepClone(obj[key]);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    //如果不是，简单复制<br>                    objClone[key] = obj[key];<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">return</span> objClone;<br>&#125;; <br>浅度：<br>1.（对象拷贝）<br>const target = &#123;&#125;;<br>const <span class="hljs-built_in">source</span> = &#123; a: &#123; b: 1 &#125; &#125;;<br>Object.assign(target, <span class="hljs-built_in">source</span>);<br>console.log(target); // &#123; a: &#123; b: 1 &#125; &#125;;<br>2.（对象拷贝）<br><span class="hljs-built_in">let</span> cloneObj = &#123; …obj &#125;;<br>3.（数组拷贝）slice 拷贝数组 <br>const arrAy= arr.slice()<br>4.（数组拷贝）、concat拷贝数组  <br>const arrAy= arr.concat()<br></code></pre></td></tr></table></figure><h3 id="11-let、var、const的区别？"><a href="#11-let、var、const的区别？" class="headerlink" title="11.let、var、const的区别？"></a>11.let、var、const的区别？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">var：只有全局作用域和函数作用域概念，没有块级作用域的概念。但是会把&#123;&#125;内也假称为块作用域。<br><span class="hljs-built_in">let</span>：只有块级作用域的概念 ，由 &#123; &#125; 包括起来，<span class="hljs-keyword">if</span>语句和<span class="hljs-keyword">for</span>语句里面的&#123; &#125;也属于块级作用域。<br>const：定义常量，赋值不可以改变<br></code></pre></td></tr></table></figure><h3 id="12-冒泡排序"><a href="#12-冒泡排序" class="headerlink" title="12.冒泡排序"></a>12.冒泡排序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 冒泡排序<br>    var arr = [2, 4, 1, 6, 7, 8, 33, 11,77,88,99,3,100];<br>    <span class="hljs-keyword">function</span> <span class="hljs-built_in">sort</span>(array) &#123;<br>        //使用双循环去遍历数组，第一个循环取 array 的一个数据，第二个循环拿上个循环数据的后面一个数据，两个数据进行比较。<br>        <span class="hljs-keyword">for</span> (var i = 0; i &lt; array.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (var u = i + 1; u &lt; array.length; u++) &#123;<br>                <span class="hljs-keyword">if</span> (array[i] &gt; array[u]) &#123;<br>                    //如果 array[i] &gt; &lt;array[u] ，就声明一个缓存遍历 num 存放大的数据，然后把两个数据的下标进行更换，达到升序排序的效果。<br>                    var num = array[i];  <br>                    array[i] = array[u];<br>                    array[u] = num;<br>                &#125;<br>            &#125;<br>        &#125;<br>        //return 根据需要可写可不写。<br>        <span class="hljs-built_in">return</span> array;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h3 id="13-递归"><a href="#13-递归" class="headerlink" title="13.递归"></a>13.递归</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 求1-100的和<br><span class="hljs-keyword">function</span> <span class="hljs-built_in">sum</span>(n)&#123;<br>            <span class="hljs-keyword">if</span>(n==1) <span class="hljs-built_in">return</span> 1<br>            <span class="hljs-built_in">return</span> <span class="hljs-built_in">sum</span>(n-1)+n<br>        &#125;<br>        console.log(<span class="hljs-built_in">sum</span>(n))<br></code></pre></td></tr></table></figure><h3 id="14-说一下重绘和回流"><a href="#14-说一下重绘和回流" class="headerlink" title="14.说一下重绘和回流"></a>14.说一下重绘和回流</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">回流(reflow)：对于DOM结构中的各个元素都有自己的盒子模型,这些都需要浏览器根据各种样式(浏览器的、开发人员定义的等)来计算并根据计算结果将元素放到它该出现的位置，这个过程称之为reflow ;<br>重绘(repaint)：当各种盒子的位置、大小以及其他属性,例如颜色、字体大小等都确定下来后,浏览器于是便把这些元素都按照各自的特性绘制了一遍,于是页面的内容出现了，这个过程称之为repaint。<br>回流(reflow)就是元素的位置发生了改变(不管是添加、删除元素，还是元素尺寸改变)，会触发回流。<br>重绘(repaint)简单的说，元素位置不会发生改变，视觉效果会有所改变<br></code></pre></td></tr></table></figure><h3 id="15-401和403的区别，201是什么，暂时重定向和永久重定向分别是哪个，以及其他状态码？"><a href="#15-401和403的区别，201是什么，暂时重定向和永久重定向分别是哪个，以及其他状态码？" class="headerlink" title="15.401和403的区别，201是什么，暂时重定向和永久重定向分别是哪个，以及其他状态码？"></a>15.401和403的区别，201是什么，暂时重定向和永久重定向分别是哪个，以及其他状态码？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">200：请求成功。<br>204：无内容，没有返回内容。<br>301：永久重定向。<br>302：临时重定向。<br>400：参数错误，服务器不识别该请求。<br>401：未授权，非本系统的用户。<br>403：禁止访问，是本系统的用户，但是没有当前请求的权限。<br>404：请求的网页不存在。<br>429：太多请求。（网关限流，你发的请求太多了）<br>499：客户端主动断开了连接。<br>500：服务器遇到错误，无法完成请求。<br>502：网关或代理服务器从上游。服务器收到无效响应，很有可能是服务挂了。<br>503：服务暂时不可用，可以稍候重试。（网关总流量到达上限）<br>504：网关超时，网关或代理服务器没有及时从上游服务器收到请求<br></code></pre></td></tr></table></figure><h3 id="16-null和undefined区别"><a href="#16-null和undefined区别" class="headerlink" title="16.null和undefined区别"></a>16.null和undefined区别</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">null表示没有对象，即该处不应该有值。典型用法是：作为函数的参数，表示该函数的参数不是对象。作为对象原型链的终点。undefined表示缺少值，就是此处应该有一个值，但是还没有定义。典型用法是：变量被声明了，但没有赋值时，就等于undefined。<br></code></pre></td></tr></table></figure><h3 id="17-如果函数没有返回值返回的是什么？"><a href="#17-如果函数没有返回值返回的是什么？" class="headerlink" title="17.如果函数没有返回值返回的是什么？"></a>17.如果函数没有返回值返回的是什么？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">javaScript中函数无返回值时，函数默认返回undefined<br></code></pre></td></tr></table></figure><h3 id="18-判断数组和对象的方法"><a href="#18-判断数组和对象的方法" class="headerlink" title="18.判断数组和对象的方法"></a>18.判断数组和对象的方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.typeOf操作符，利用typeOf除了array和 null 判断为Object外，其他的都可以正常判断<br><br>2.instanceof操作符<br>这个操作符是检测对象的原型链是否指向构造函数的prototype对象的<br>var arr =[1,2,3]<br>console.log(arr.instanceof Array) //true<br><br>3.对象的constructor的属性<br>除了instanceof，每个对象还有constructor的属性，利用它似乎也能进行Array的判断。<br>var arr =[1,2,3]<br>console.log(arr.constructor === Array) //true<br><br>4.Object.prototype.toString<br><span class="hljs-keyword">function</span> isArray (o)&#123;<br> <span class="hljs-built_in">return</span> Object.prototype.toString.call(o) === <span class="hljs-string">&#x27;[object Array]&#x27;</span><br>&#125;<br>var arr = [1,2,3]<br>alert (isArrayFn(arr)) //true<br><br>5.Array.isArray<br>ECMASCript5将Array.isArray()正式引入JavaScript，目的就是准确的检测一个值是否为数组。IE9+、FireFox4+、Safari5+、Opera10.5+和Chrome都实现了这个方法。但是在IE8之前的版本是不支持的。<br></code></pre></td></tr></table></figure><h3 id="19-forEach、map、filter、reduce的区别？"><a href="#19-forEach、map、filter、reduce的区别？" class="headerlink" title="19.forEach、map、filter、reduce的区别？"></a>19.forEach、map、filter、reduce的区别？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.相同点<br><br>map、filter、reduce执行匿名函数支持三个参数，分别是：当前元素、当前元素索引、当前元素所属的数组<br>匿名函数this指向window<br>只能遍历数组<br>2.不同点<br><br>map速度比forEach快<br>map和filter返回新数组，不会影响原数组；forEach不会产生新数组，返回undefined，reduce把数组缩减为一个值（求和，求积）<br>reduce有4个参数，第一个为初始值<br><br>3.forEach语法<br><br>var arr1 = [<span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br>arr1.forEach(<span class="hljs-keyword">function</span>(item) &#123;<br>    // console.log(item)<br>&#125;)<br><br>4.map语法<br><br>var arr2 = [1, 2, 3, 4, 5]<br>const map1 = arr2.map(x =&gt; x * 2)<br>console.log(map1) // [ 2, 4, 6, 8, 10 ]<br><br>5.filter语法<br><br>var words = [<span class="hljs-string">&#x27;sprif&#x27;</span>, <span class="hljs-string">&#x27;dseee&#x27;</span>, <span class="hljs-string">&#x27;eliter&#x27;</span>, <span class="hljs-string">&#x27;exhaust&#x27;</span>, <span class="hljs-string">&#x27;present&#x27;</span>]<br>const result = words.filter(words =&gt; words.length &gt; 4)<br>console.log(words)<br><br>6.reduce语法<br><br>var arr2 = [1, 2, 3, 4, 5]<br>const reducer = (acc, current) =&gt; acc + current<br>console.log(arr2.reduce(reducer, 5))  //20<br>console.log(arr2.reduce(reducer)) // 15<br></code></pre></td></tr></table></figure><h3 id="20-说一下es6"><a href="#20-说一下es6" class="headerlink" title="20.说一下es6"></a>20.说一下es6</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span>、const、箭头函数、扩展运算符、模板字符串、Map和Set、symbol、引入导出、类和继承、Promise、async/await、new Set数组去重等<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文档支持的Markdown语法</title>
    <link href="/2020/11/20/2020-11-20-markdownTool/"/>
    <url>/2020/11/20/2020-11-20-markdownTool/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是-Markdown"><a href="#什么是-Markdown" class="headerlink" title="什么是 Markdown"></a>什么是 Markdown</h2><p>Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：如您正在阅读的这篇文章。它使用简单的符号标记不同的标题，分割不同的段落，<strong>粗体</strong> 或者 <em>斜体</em> 某些文字.</p><p>很多产品的文档也是用markdown编写的，并且以“README.MD”的文件名保存在软件的目录下面。　　</p><h2 id="一些基本语法"><a href="#一些基本语法" class="headerlink" title="一些基本语法"></a>一些基本语法</h2><p>标题<br>H1 :# Header 1<br>H2 :## Header 2<br>H3 :### Header 3<br>H4 :#### Header 4<br>H5 :##### Header 5<br>H6 :###### Header 6<br>链接 :<a href="URL">Title</a><br>加粗 :<strong>Bold</strong><br>斜体字 :<em>Italics</em><br>*删除线 :<del>text</del><br>内嵌代码 : <code>alert(&#39;Hello World&#39;);</code>        </p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul><li>列表1</li><li>列表2</li><li>列表3</li></ul><h3 id="列表引用"><a href="#列表引用" class="headerlink" title="列表引用"></a>列表引用</h3><blockquote><ul><li>列表1</li><li>列表2</li><li>列表3</li></ul></blockquote><h3 id="插入一张图片"><a href="#插入一张图片" class="headerlink" title="插入一张图片"></a>插入一张图片</h3><p>打赏一个吧</p><p><img src="/images/payimg/weipayimg.jpg"></p><p>css 的大部分语法同样可以在 markdown 上使用，但不同的渲染器渲染出来的 markdown 内容样式也不一样，下面这些链接里面有 markdown 基本语法，你也可以在下面几个平台上尝试着写一些。</p><h2 id="博客支持的高级语法"><a href="#博客支持的高级语法" class="headerlink" title="博客支持的高级语法"></a>博客支持的高级语法</h2><h3 id="1-制作一份待办事宜"><a href="#1-制作一份待办事宜" class="headerlink" title="1. 制作一份待办事宜"></a>1. 制作一份待办事宜</h3><ul><li><input disabled type="checkbox"> 支持以 PDF 格式导出文稿</li><li><input disabled type="checkbox"> 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li><li><input checked disabled type="checkbox"> 新增 Todo 列表功能</li><li><input checked disabled type="checkbox"> 修复 图标功能</li></ul><h3 id="2-高亮一段代码"><a href="#2-高亮一段代码" class="headerlink" title="2. 高亮一段代码"></a>2. 高亮一段代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-meta">@requires_authorization</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeClass</span>:<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># A comment</span><br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;hello world&#x27;</span><br><br></code></pre></td></tr></table></figure><h4 id="3-绘制表格"><a href="#3-绘制表格" class="headerlink" title="3. 绘制表格"></a>3. 绘制表格</h4><table><thead><tr><th>项目</th><th align="right">价格</th><th align="center">数量</th></tr></thead><tbody><tr><td>计算机</td><td align="right">$1600</td><td align="center">5</td></tr><tr><td>手机</td><td align="right">$12</td><td align="center">12</td></tr><tr><td>管线</td><td align="right">$1</td><td align="center">234</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HEXO搭建个人博客</title>
    <link href="/2020/08/25/2020-08-25-HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/08/25/2020-08-25-HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>　　经过各种找资料，踩过各种坑，终于使用 hexo 搭建个人博客初步完成了，域名目前用得时 github 的，我的 hexo 是 3.1.1 版本，hexo 不同的版本，很多配置都不一样。好吧，废话不多说了，开始吧。     </p><p>　　本篇文章累计了大量评论，和我的一些解答，读者有什么问题可以先看看评论，或者搜下关键字，如果还是有问题可以给我在评论里给我留言，问题很着急的可以加我 ＱＱ：1192314331　，或者给我发邮件：<a href="heimanbads@163.com">heimanbads@163.com</a>  ，都可以，如果你已经搭建完成了，可以看看我的另一篇博客<a href="http://boobar.cn/2020/06/HEXO_Advanced/">HEXO进阶</a>，有讲如何能百度搜索你的博客、多台电脑使用HEXO发布博客等。我现在的博客是使用 Jekyll 搭建的，如果你想使用我现在的模板请看<a href="http://boobar.cn/2020/10/jekyll_tutorials1/">Jekyll搭建个人博客</a> </p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>　这篇教程是针对与Mac的，<a href="http://ibruce.info/2020/11/22/hexo-your-blog/?utm_source=tuicool">参考链接</a>，由于原文讲到的hexo是以前的老版本，所以现在的版本配置的时候会有些改动。</p><p>　之前是想着写博客，一方面是给自己做笔记，可以提升自己的写作、总结能力，一个技术点我们会使用，并不难，但是要做到让让别人也能听懂我们讲得，还是需要一定的技巧和经验的。很多类似于CSDN、博客园也都可以写文章，但是页面的样式我，不是太喜欢，简书还算好点得。最近看到一些大神们的博客（在我的友情链接里有），貌似都是用hexo写得，我也依葫芦画瓢的搭建了一个。不罗嗦了，直接上搭建步骤。</p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><h3 id="安装Node（必须）"><a href="#安装Node（必须）" class="headerlink" title="安装Node（必须）"></a>安装Node（必须）</h3><p>作用：用来生成静态页面的<br>到Node.js<a href="https://nodejs.org/">官网</a>下载相应平台的最新版本，一路安装即可。</p><h3 id="安装Git（必须）"><a href="#安装Git（必须）" class="headerlink" title="安装Git（必须）"></a>安装Git（必须）</h3><p>作用：把本地的hexo内容提交到github上去.<br>安装Xcode就自带有Git，我就不多说了。</p><h3 id="申请GitHub（必须）"><a href="#申请GitHub（必须）" class="headerlink" title="申请GitHub（必须）"></a>申请GitHub（必须）</h3><p>作用：是用来做博客的远程创库、域名、服务器之类的，怎么与本地hexo建立连接等下讲。<br><a href="https://github.com/">github</a>账号我也不再啰嗦了,没有的话直接申请就行了，跟一般的注册账号差不多，SSH Keys，看你自己了，可以不配制，不配置的话以后每次对自己的博客有改动提交的时候就要手动输入账号密码，配置了就不需要了，怎么配置我就不多说了，网上有很多教程。</p><h3 id="正式安装HEXO"><a href="#正式安装HEXO" class="headerlink" title="正式安装HEXO"></a>正式安装HEXO</h3><p>Node和Git都安装好后，可执行如下命令安装hexo：</p><pre><code class="hljs">$ sudo npm install -g hexo</code></pre><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>创建一个文件夹，如：Blog，cd到Blog里执行hexo init的。命令：</p><pre><code class="hljs">hexo init</code></pre><p>好啦，至此，全部安装工作已经完成！</p><h3 id="生成静态页面"><a href="#生成静态页面" class="headerlink" title="生成静态页面"></a>生成静态页面</h3><p>继续再Blog目录下执行如下命令，生成静态页面</p><pre><code class="hljs">hexo generate （hexo g  也可以）   </code></pre><h3 id="本地启动"><a href="#本地启动" class="headerlink" title="本地启动"></a>本地启动</h3><p>启动本地服务，进行文章预览调试，命令：</p><pre><code class="hljs">hexo server   </code></pre><p>浏览器输入<a href="%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%9C%80%E5%8E%9F%E5%A7%8B%E7%9A%84%E6%95%88%E6%9E%9C%E4%BA%86">http://localhost:4000</a><br>我不知道你们能不能，反正我不能，因为我还有环境没配置好</p><h3 id="常见的HEXO配置错误："><a href="#常见的HEXO配置错误：" class="headerlink" title="常见的HEXO配置错误："></a>常见的HEXO配置错误：</h3><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">ERROR </span>Plugin load failed: hexo-server<br><br>原因： Besides, utilities are separated into a standalone module. hexo.util is not reachable anymore.<br><br>解决方法，执行命令：$ sudo npm install hexo-server<br><br></code></pre></td></tr></table></figure><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs axapta">执行命令hexo <span class="hljs-keyword">server</span>，提示：Usage: hexo&lt;Command&gt; ....<br><br>原因：我认为是没有生成本地服务<br><br>解决方法，执行命令：$ npm install hexo-<span class="hljs-keyword">server</span> --save<br><br>提示：hexo-<span class="hljs-keyword">server</span>@<span class="hljs-number">0.1</span><span class="hljs-number">.2</span> node_modules/hexo-<span class="hljs-keyword">server</span><br>.... <br><br>表示成功了[参考](https:<span class="hljs-comment">//hexo.io/zh-cn/docs/server.html)</span><br><br></code></pre></td></tr></table></figure><p>这个时候再执行：$ hexo-server</p><p>得到: INFO  Hexo is running at <a href="http://0.0.0.0:4000/">http://0.0.0.0:4000/</a>. Press Ctrl+C to stop.</p><p>这个时候再点击<a href="http://0.0.0.0:4000/">http://0.0.0.0:4000</a>，正常情况下应该是最原始的画面，但是我看到的是：<br>白板和Cannot GET &#x2F;   几个字<br>原因： 由于2.6以后就更新了，我们需要手动配置些东西，我们需要输入下面三行命令：</p><pre><code class="hljs">npm install hexo-renderer-ejs --savenpm install hexo-renderer-stylus --savenpm install hexo-renderer-marked --save</code></pre><p>这个时候再重新生成静态文件，命令：</p><pre><code class="hljs">hexo generate （或hexo g）</code></pre><p>启动本地服务器：</p><pre><code class="hljs">hexo server （或hexo s）</code></pre><p>再点击网址<a href="http://0.0.0.0:4000/">http://0.0.0.0:4000</a> OK终于可以看到属于你自己的blog啦，?，虽然很简陋，但好歹有了一个属于自己的小窝了。<a href="https://disqus.com/home/discussion/bsspirit/hexogithubweb/">参考链接</a>，本地已经简单的设置好了，但是现在域名和服务器都是基于自己的电脑，接下来需要跟github进行关联。</p><h2 id="配置Github"><a href="#配置Github" class="headerlink" title="配置Github"></a>配置Github</h2><h3 id="建立Repository"><a href="#建立Repository" class="headerlink" title="建立Repository"></a>建立Repository</h3><p>建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法<br>然后建立关联，我的Blog在本地&#x2F;Users&#x2F;leopard&#x2F;Blog，Blog是我之前建的东西也全在这里面，有：</p><blockquote><p>Blog<br>　｜<br>　｜－－ _config.yml<br>　｜－－ node_modules<br>　｜－－ public<br>　｜－－ source<br>　｜－－ db.json<br>　｜－－ package.json<br>　｜－－ scaffolds<br>　｜－－ themes          　　　　　　　　</p></blockquote><p>现在我们需要_config.yml文件，来建立关联，命令：</p><pre><code class="hljs">vim _config.yml</code></pre><p>翻到最下面，改成我这样子的，注意： <code>: 后面要有空格</code></p><pre><code class="hljs">deploy:  type: git  repository: https://github.com/boobar/boobar.github.io.git  branch: master</code></pre><p>执行如下命令才能使用git部署</p><pre><code class="hljs">npm install hexo-deployer-git --save</code></pre><p>网上会有很多说法，有的type是github, 还有repository 最后面的后缀也不一样，是github.com.git，我也踩了很多坑，我现在的版本是hexo: 3.1.1，执行命令hexo -vsersion就出来了,貌似3.0后全部改成我上面这种格式了。<br>忘了说了，我没用SSH Keys如果你用了SSH Keys的话直接在github里复制SSH的就行了，总共就两种协议，相信你懂的。<br>然后，执行配置命令：</p><pre><code class="hljs">hexo deploy</code></pre><p>　然后再浏览器中输入<a href="http://boobar.github.io/">http://boobar.github.io/</a>就行了，我的 github 的账户叫 boobar ,把这个改成你 github 的账户名就行了</p><h3 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h3><p>每次部署的步骤，可按以下三步来进行。</p><pre><code class="hljs">hexo cleanhexo generatehexo deploy</code></pre><p>一些常用命令：</p><pre><code class="hljs">hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help  #查看帮助hexo version  #查看Hexo的版本</code></pre><p>这里有大量的<a href="https://github.com/hexojs/hexo/wiki/Themes">主题列表</a>使用方法里面<br>都有详细的介绍，我就不多说了。<br>我这里有几款个人认为不错的主题，免去你们，一个一个的选了，欢迎吐槽我的审美，?<br>　<a href="https://github.com/daisygao/hexo-themes-cover">Cover</a> - A chic theme with facebook-like cover photo<br>　<a href="https://github.com/henryhuang/oishi">Oishi</a> - A white theme based on Landscape plus and Writing.<br>　<a href="https://github.com/hardywu/hexo-theme-sidebar">Sidebar</a> - Another theme based on Light with a simple sidebar<br>　<a href="https://github.com/SuperKieran/TKL">TKL</a> - A responsive design theme for Hexo. 一个设计优雅的响应式主题<br>　<a href="https://github.com/levonlin/Tinnypp">Tinnypp</a> - A clean, simple theme based on Tinny<br>　<a href="https://github.com/yunlzheng/hexo-themes-writing">Writing</a> - A small and simple hexo theme based on Light<br>　<a href="https://github.com/litten/hexo-theme-yilia">Yilia</a> - Responsive and simple style 优雅简洁响应式主题，我用得就是这个。<br>　<a href="https://github.com/Voidly/pacman">Pacman voidy</a> - A theme with dynamic tagcloud and dynamic snow      </p><h2 id="博客目录介绍"><a href="#博客目录介绍" class="headerlink" title="博客目录介绍"></a>博客目录介绍</h2><p>　文章在 source&#x2F;_posts，编辑器可以用 Sublime，支持 markdown 语法。如果想修改头像可以直接在主题的 _config.yml 文件里面修改，友情链接，之类的都在这里，修改名字在 public&#x2F;index.html 里修改，开始打理你的博客吧，有什么问题或者建议，都可以提出来，我会继续完善的。</p><p>Markdown语法参考链接: <a href="https://www.zybuluo.com/mdeditor">作业部落</a></p><h2 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><blockquote><p>问：如何让文章想只显示一部分和一个 <code>阅读全文</code> 的按钮？<br>答：在文章中加一个 <code>&lt;!--more--&gt;</code> ， <code>&lt;!--more--&gt;</code> 后面的内容就不会显示出来了。</p></blockquote><p> </p><blockquote><p>问：本地部署成功了，也能预览效果，但使用 username.github.io 访问，<code>出现 404 </code> .<br>答：首先确认 hexo d 命令执行是否报错，如果没有报错，再查看一下你的 github 的 username.github.io 仓库，你的博客是否已经成功提交了，你的 github 邮箱也要通过验证才行。</p></blockquote><p> </p><p>转载请注明原地址，黄冠凯的博客：<a href="https://boobar.asia/">https://boobar.asia</a> 谢谢！</p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客模板功能介绍</title>
    <link href="/2020/07/11/2020-07-11-blog_info/"/>
    <url>/2020/07/11/2020-07-11-blog_info/</url>
    
    <content type="html"><![CDATA[<p>在此之前我有写过一篇<a href="https://github.com/HeiManBs/Boobar.Github.io/tree/dev">如何使用我博客模板的文章</a> 请先看这篇基础集成，这篇文章主要讲的是如何使用和修改我的博客主题，文章内容含以下几点：</p><h2 id="博客特性"><a href="#博客特性" class="headerlink" title="博客特性"></a>博客特性</h2><ul><li><input checked disabled type="checkbox"> 适配电脑、手机、平板等各屏幕</li><li><input checked disabled type="checkbox"> 响应式设计</li><li><input checked disabled type="checkbox"> 个性化头像</li><li><input checked disabled type="checkbox"> 每篇文章自动添加打赏功能</li><li><input checked disabled type="checkbox"> 支持Disqus、livere评论系统</li><li><input checked disabled type="checkbox"> 支持站点总数访问统计，每篇文章访问统计</li><li><input checked disabled type="checkbox"> 支持文章自动生成目录</li><li><input checked disabled type="checkbox"> 支持标签分类</li><li><input checked disabled type="checkbox"> 支持代码高亮</li><li><input checked disabled type="checkbox"> 支持文章H1、H2、H3、H4标题样式多样化</li><li><input checked disabled type="checkbox"> 支持多种三方社交icon展示，能从博客直接跳转到自己的三方社交主页</li><li><input checked disabled type="checkbox"> 支持三方社交分享(facebook、twitter)</li></ul><h2 id="博客主要模块介绍"><a href="#博客主要模块介绍" class="headerlink" title="博客主要模块介绍"></a>博客主要模块介绍</h2><h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h3><p><code>_config.yml</code> 是博客的配置文件，整个站点的信息都在这修改，想要把我的模板改成你自己的也需要修改<code>_config.yml</code> </p><p><strong>重要字段说明</strong> </p><ul><li>enableToc: 是否开启文章自动生成目录，设置为false文章不会自动生成目录</li><li>comment&#x2F;livere: livere评论系统，支持微信、qq、微博、豆瓣、twitter等登录后可以直接评论</li><li>comment&#x2F;disqus: disqus评论系统，支持facebook、twitter等登录后可以直接评论</li><li>social&#x2F;weibo、github、zhihu、jianshu等: 个人站底部展示的微博等三方社交按钮，点击后直接跳转到个人微博或其他社交主页</li><li>baidu&#x2F;id: 百度统计，用来统计你个人站点的用户访问情况</li><li>ga&#x2F;id: google统计，用来统计你个人站点的用户访问情况</li></ul><p>_config.yml 文件除以上字段还有一些可以自行修改，例如title之类的字段</p><h3 id="posts"><a href="#posts" class="headerlink" title="_posts"></a>_posts</h3><p><code>_posts</code> 目录是用来存放文章的目录，写新文章，直接放在这个目录即可</p><p>使用博客模板时，请把博客自带的文章给去掉，如果想使用博客自带的文章请 <code>注明出处</code>。</p><h3 id="自定义页面"><a href="#自定义页面" class="headerlink" title="自定义页面"></a>自定义页面</h3><p>about.md、support.md 等为自定义页面，如果你想添加自动以页面可以直接复制about.md 文件修改文件名和里面的内容即可。</p><p>如果需要在导航显示你新增的页面，直接在<code>_config.yml</code> 文件的nav字段中添加你新页面配置即可</p><h3 id="修改说明"><a href="#修改说明" class="headerlink" title="修改说明"></a>修改说明</h3><p>如果要修改博客模板信息建议只修改<code>_config.yml</code> 文件内容和 <code>_posts</code> 里面的文章信息。因为博客模板一直在更新迭代，改动多了以免你后期更新博客模板的时候不方便。</p><p>如果你想改动模板的样式又想继续更新迭代博客模板，你可以提交在github上提交<code>pull request</code> 或者直接给我发邮件建议改成什么样，如果你的提议确实可以，我会采纳的，并且非常感谢你的建议。</p><p>博客迭代信息请看<a href="https://github.com/HeiManBs/Boobar.Github.io/tree/dev">ReleaseNode</a></p><p>遇到解决不了的问题可以找 <a href="https://github.com/HeiManBs/Boobar.Github.io/tree/dev">技术支持</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>jekyll</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客迭代记录</title>
    <link href="/2020/07/10/2020-07-10-ReleaseNode/"/>
    <url>/2020/07/10/2020-07-10-ReleaseNode/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本博客首发时间为2020年，至今已经3个年头了。</p><p>感觉之前更新迭代的有点乱，很多用户在使用的时候也没法确定是否要更新新版的博客，再次我专门用一篇文章来记录博客更新迭代的记录，如果你已经在使用我的博客模板的，你可以看看更新记录后确认下是否要更新。</p><!-- 博客的全功能介绍请看[博客功能介绍](https://github.com/HeiManBs/Boobar.Github.io/tree/dev) --><h2 id="1-0-0"><a href="#1-0-0" class="headerlink" title="1.0.0"></a>1.0.0</h2><p>2020-11-25 第一版发布，红色主题</p><h2 id="2-0-0-开发中"><a href="#2-0-0-开发中" class="headerlink" title="2.0.0 开发中"></a>2.0.0 开发中</h2><ul><li>2020-11-25 修改博客风格为淡蓝色主题</li><li>2020-12-16 增长404、about等页面</li><li>2021-1-12 增加代码高亮</li><li>2021-3-19 增加打赏公共</li><li>2022-9-8 多说评论系统停服，切换到disqus评论（多说上的评论全没了😭）</li><li>2023-1-25 增加博客底部社交链接<!-- * 2020-7-8 博客域名从 [http://baixin.io](http://baixin.io) 迁移到 [http://boobar.cn](http://boobar.cn) （baixin.io没法备案之前的统计也全没了😭）. --></li><li>2020-7-13 增加文章自动生成目录功能, 增加livere评论系统</li></ul><h2 id="博客更新手册"><a href="#博客更新手册" class="headerlink" title="博客更新手册"></a>博客更新手册</h2><p>如果你已经在使我的博客模板了，现在又想继续更新新版的博客，你下载博客后只需要修改两个各方</p><ul><li>_config.yml 文件</li><li>_posts 目录</li></ul><p><code>_config.yml</code> 文件里面的内容设置成你自己的，也可以用你原来的，最好是更新版的字段做一下对比。</p><p><code>_posts</code> 目录里面的文章全部删掉，把你自己的文章放进来</p><p>修改以上两个地方新版的博客便更新完成，快看看效果吧！</p>]]></content>
    
    
    
    <tags>
      
      <tag>jekyll</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HEXO进阶</title>
    <link href="/2020/06/12/2020-06-12-HEXO_Advanced/"/>
    <url>/2020/06/12/2020-06-12-HEXO_Advanced/</url>
    
    <content type="html"><![CDATA[<p>HEXO接近是最近有一些朋友提出的问题，然后我做了总结，如果你也在使用HEXO，不妨看看，应该会有些帮助。</p><ul><li>1、博客部署样式出问题了怎么办？</li><li>2、电脑重装或者误删了本地博客怎么办？</li><li>3、想使用两台电脑写博客怎么办？</li><li>4、为何使用百度搜不到我的博客？</li></ul><h3 id="使用Jekyll解决前三个问题。"><a href="#使用Jekyll解决前三个问题。" class="headerlink" title="使用Jekyll解决前三个问题。"></a>使用Jekyll解决前三个问题。</h3><p>不得不说 <code>Jekyll</code> 确实可以解决我上面三个问题, 因为 <code>Jekyll</code> 是直接把Markdown格式的文章直接放在github仓库里的, 相当于直接用git来管理博客了, <code>Github</code> 官方也很推荐 <code>Jekyll</code> 。 你可以先看下 <code>Jekyll</code> 搭建博客的<a href="voyagelab.github.io">voyagelab</a>, <a href="https://github.com/voyagelab/voyagelab.github.io">github地址</a>, 当然了这只是很普通的, Jekyll 也有很多主题可以选择的, 更详细的请看<a href="http://jekyll.bootcss.com/">Jekyll中文文档</a>、<a href="https://jekyllrb.com/">Jekyll英文文档</a>、<a href="http://jekyllthemes.org/">Jekyll主题列表</a>。<br>在 <code>Jekyll</code> 上逛了一个星期的我又回到了 <code>Hexo</code> , 发现 目前 <code>Jekyll</code> 对主题和一些插件的支持相对 <code>Hexo</code> 来说, 没那么友好, 可能有一些其它的方法只是我没找到而已,关于 <code>Jekyll</code> 搭建博客就介绍到这, 如果有问题的话可以评论, 或者联系我。</p><h3 id="使用Hexo解决上面前三个问题"><a href="#使用Hexo解决上面前三个问题" class="headerlink" title="使用Hexo解决上面前三个问题"></a>使用Hexo解决上面前三个问题</h3><p>是的, 我大<code>Hexo</code>同样可以解决上面三个问题, 那就是使用git。关于如何使用 <code>Hexo</code> 搭建博客请看我另一篇文章<a href="http://www.boobar.cn/2015/08/25/HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">HEXO搭建个人博客</a>, 如果搭建的过程中出现了问题, 我们可以交流交流。现在我假设你已经能基本使用 <code>Hexo</code> 了, 接下来就看看如何来管理博客。</p><h2 id="使用git管理博客"><a href="#使用git管理博客" class="headerlink" title="使用git管理博客"></a>使用git管理博客</h2><p><a href="https://github.com/boobar/Blog-Growing">Blog-Growing</a>是我管理博客的仓库地址。结构大致是:</p><blockquote><p>– Blog-Growing<br>　　|– .git<br>　　|– .gitignore<br>　　|– Hexo<br>　　　　|   ..<br>　　　　|   ..<br>　　　　|   整个博客的配置信息    </p></blockquote><p>你可以把我的的<a href="https://github.com/boobar/Blog-Growing">Blog-Growing</a> clone下来, 看看一些基本配置是怎么配置的。需要提醒的是, <code>要把主题下的.git给删除掉</code> , 当然了你也可以使用 <code>git submodule</code> 来管理, 具体的管理方法我这里就不做多的介绍了, 想了解的话可以私信我。<br>上面的过程基本做完后, 怎么来解决我开篇提的前三个问题了。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现:"></a>具体实现:</h3><p><strong>一：家里电脑使用博客</strong><br>　　建立git远端仓库管理博客,并使用家里的电脑把本地博客的配置推送到远端仓库。<br><strong>二：公司电脑使用博客</strong><br>　　到了公司只需要执行<code>sudo npm install -g hexo</code>,然后cd到你的博客目录下,如我cd 到Hexo目录下, 然后执行 <code>hexo server</code> 就可以在本地预览博客了。<br><strong>三：使用Git保存</strong><br>　　修改好博客后记得先使用git来提交下, 即使下次把博客的样式修改坏了, 也可以使用 <code>git reset --hard</code> 来回退。如: 我cd 到 <code>Blog-Growing</code> 目录下使用git提交。<br><strong>四：博客提交</strong><br>　　1、修改好的博客使用 <code>hexo d</code> 展示到博客页上。<br>　　2、git push 整个本地博客。    </p><p><strong>提示:</strong> 在这里 <code>git</code> 仅仅只是用户做博客的版本管理的, 博客的样式修改、基本部署还是使用 <code>hexo</code> 来操作的。</p><h2 id="让百度能搜索到你的博客"><a href="#让百度能搜索到你的博客" class="headerlink" title="让百度能搜索到你的博客"></a>让百度能搜索到你的博客</h2><h3 id="为什么要使用百度搜索？"><a href="#为什么要使用百度搜索？" class="headerlink" title="为什么要使用百度搜索？"></a>为什么要使用百度搜索？</h3><p>　　有人可能会说作为一个开发人员, 你不会用 <code>Google</code> 啊。 是的, Google是能搜到我们搭建在 <code>Github Page</code> 的博客, 会用<code>Google</code> 也是一个开发人员必备技能之一。但是, 我们生活在天朝, 所以百度还是总有会用到的时候, 或者是你想让更多的天朝人能搜到你。</p><h3 id="为什么使用百度搜索不到-Github-Page-上的博客？"><a href="#为什么使用百度搜索不到-Github-Page-上的博客？" class="headerlink" title="为什么使用百度搜索不到 Github Page 上的博客？"></a>为什么使用百度搜索不到 Github Page 上的博客？</h3><p>有人联系过 Github Support 部门 , 给出大致的意思就是: 百度爬虫爬得太猛烈，已经对很多 Github 用户造成了问题。所以 Github 将禁止百度爬虫的爬取。    </p><h3 id="如何让百度能搜索你的博客"><a href="#如何让百度能搜索你的博客" class="headerlink" title="如何让百度能搜索你的博客?"></a>如何让百度能搜索你的博客?</h3><p>　　根据上面说的, 目前发现只是Github Page禁止了百度搜索, 所以让百度能搜索到你的博客还是有一些方法的。例如:</p><ul><li>自己搞个VPS,博客部署在VPS上。</li><li>博客部署 <code>Coding.net</code> 上, <code>GitCafe</code>已经合并到 <code>Coding</code> 。<br>我使用的是第二种方法, 博客部署在 <code>Coding.net</code> 上也相对简单些。</li></ul><h4 id="在Coding上部署你的博客。"><a href="#在Coding上部署你的博客。" class="headerlink" title="在Coding上部署你的博客。"></a>在Coding上部署你的博客。</h4><p>　　Coding同样支持Hexo、Jekyll等博客的部署, Coding 跟Github还是挺像的,而且是中文。 同样的在Coding里面建一个项目,项目名字跟你的用户名一样,这里我就不啰嗦了, 说几个需要注意的地方:<br><strong>注意一:</strong><br>　　在<code>Coding Page</code> 上部署博客,需要把博客推送到<code>coding-pages </code> 分支上, 分支名字是固定的。<br><strong>注意二:</strong><br>　　<code>Coding Page</code> 不支持自定义CNAME, 你需要点击到Page模块,然后添加一个域名来绑定。   </p><p>更详细的请看<a href="https://coding.net/help/doc/pages/index.html">Coding Pages 官网介绍</a>.     </p><p>参考文章:<br><a href="http://jerryzou.com/posts/feasibility-of-allowing-baiduSpider-for-Github-Pages/">解决 Github Pages 禁止百度爬虫的方法与可行性分析</a></p><br><p>转载请注明：<a href="https://boobar.asia/">黄冠凯的博客</a> » <a href="http://boobar.cn/2016/06/HEXO_Advanced/">点击阅读原文</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
